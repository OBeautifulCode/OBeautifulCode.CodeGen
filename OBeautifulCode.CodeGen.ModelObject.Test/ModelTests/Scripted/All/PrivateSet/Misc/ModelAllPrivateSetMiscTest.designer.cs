// --------------------------------------------------------------------------------------------------------------------
// <auto-generated>
//   Generated using OBeautifulCode.CodeGen.ModelObject (1.0.0.0)
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.CodeGen.ModelObject.Test.Test
{
    using global::System;
    using global::System.CodeDom.Compiler;
    using global::System.Collections.Concurrent;
    using global::System.Collections.Generic;
    using global::System.Collections.ObjectModel;
    using global::System.Diagnostics.CodeAnalysis;
    using global::System.Globalization;
    using global::System.Linq;
    using global::System.Reflection;

    using global::FakeItEasy;

    using global::OBeautifulCode.Assertion.Recipes;
    using global::OBeautifulCode.AutoFakeItEasy;
    using global::OBeautifulCode.CodeGen.ModelObject.Recipes;
    using global::OBeautifulCode.DateTime.Recipes;
    using global::OBeautifulCode.Equality.Recipes;
    using global::OBeautifulCode.Math.Recipes;
    using global::OBeautifulCode.Reflection.Recipes;
    using global::OBeautifulCode.Representation.System;
    using global::OBeautifulCode.Serialization;
    using global::OBeautifulCode.Serialization.Recipes;
    using global::OBeautifulCode.Type;

    using global::Xunit;

    using static global::System.FormattableString;

    public static partial class ModelAllPrivateSetMiscTest
    {
        private static readonly StringRepresentationTestScenarios<ModelAllPrivateSetMisc> StringRepresentationTestScenarios = new StringRepresentationTestScenarios<ModelAllPrivateSetMisc>()
            .AddScenario(() =>
                new StringRepresentationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "Default Code Generated Scenario",
                    SystemUnderTestExpectedStringRepresentationFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new SystemUnderTestExpectedStringRepresentation<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = systemUnderTest,
                            ExpectedStringRepresentation = Invariant($"OBeautifulCode.CodeGen.ModelObject.Test.ModelAllPrivateSetMisc: CollectionInterfaceOfStringProperty = {systemUnderTest.CollectionInterfaceOfStringProperty?.ToString() ?? "<null>"}, ListInterfaceOfStringProperty = {systemUnderTest.ListInterfaceOfStringProperty?.ToString() ?? "<null>"}, ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty = {systemUnderTest.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty?.ToString() ?? "<null>"}, CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty = {systemUnderTest.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty?.ToString() ?? "<null>"}, ListInterfaceOfCollectionInterfaceOfStringProperty = {systemUnderTest.ListInterfaceOfCollectionInterfaceOfStringProperty?.ToString() ?? "<null>"}, ReadOnlyListInterfaceOfListInterfaceOfStringProperty = {systemUnderTest.ReadOnlyListInterfaceOfListInterfaceOfStringProperty?.ToString() ?? "<null>"}, DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty = {systemUnderTest.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty?.ToString() ?? "<null>"}, ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty = {systemUnderTest.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty?.ToString() ?? "<null>"}, ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty = {systemUnderTest.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty?.ToString() ?? "<null>"}, ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty = {systemUnderTest.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty?.ToString() ?? "<null>"}."),
                        };

                        return result;
                    },
                });

        private static readonly ConstructorArgumentValidationTestScenarios<ModelAllPrivateSetMisc> ConstructorArgumentValidationTestScenarios = new ConstructorArgumentValidationTestScenarios<ModelAllPrivateSetMisc>()
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'collectionInterfaceOfStringProperty' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             null,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "collectionInterfaceOfStringProperty", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'collectionInterfaceOfStringProperty' is an empty enumerable scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             new List<string>(),
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "collectionInterfaceOfStringProperty", "is an empty enumerable", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'collectionInterfaceOfStringProperty' contains a null element scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             new string[0].Concat(referenceObject.CollectionInterfaceOfStringProperty).Concat(new string[] { null }).Concat(referenceObject.CollectionInterfaceOfStringProperty).ToList(),
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "collectionInterfaceOfStringProperty", "contains at least one null element", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'collectionInterfaceOfStringProperty' contains a white space element scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             new string[0].Concat(referenceObject.CollectionInterfaceOfStringProperty).Concat(new string[] { "  \r\n  " }).Concat(referenceObject.CollectionInterfaceOfStringProperty).ToList(),
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "collectionInterfaceOfStringProperty", "contains an element that is white space", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'listInterfaceOfStringProperty' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             null,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "listInterfaceOfStringProperty", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'listInterfaceOfStringProperty' is an empty enumerable scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             new List<string>(),
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "listInterfaceOfStringProperty", "is an empty enumerable", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'listInterfaceOfStringProperty' contains a null element scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             new string[0].Concat(referenceObject.ListInterfaceOfStringProperty).Concat(new string[] { null }).Concat(referenceObject.ListInterfaceOfStringProperty).ToList(),
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "listInterfaceOfStringProperty", "contains at least one null element", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'listInterfaceOfStringProperty' contains a white space element scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             new string[0].Concat(referenceObject.ListInterfaceOfStringProperty).Concat(new string[] { "  \r\n  " }).Concat(referenceObject.ListInterfaceOfStringProperty).ToList(),
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "listInterfaceOfStringProperty", "contains an element that is white space", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'readOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             null,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "readOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'readOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty' is an empty enumerable scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             new List<ICollection<string>>(),
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "readOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty", "is an empty enumerable", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'readOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty' contains a null element scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             new ICollection<string>[0].Concat(referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty).Concat(new ICollection<string>[] { null }).Concat(referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty).ToList(),
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "readOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty", "contains at least one null element", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'collectionInterfaceOfReadOnlyListInterfaceOfStringProperty' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             null,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "collectionInterfaceOfReadOnlyListInterfaceOfStringProperty", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'collectionInterfaceOfReadOnlyListInterfaceOfStringProperty' is an empty enumerable scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             new List<IReadOnlyList<string>>(),
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "collectionInterfaceOfReadOnlyListInterfaceOfStringProperty", "is an empty enumerable", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'collectionInterfaceOfReadOnlyListInterfaceOfStringProperty' contains a null element scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             new IReadOnlyList<string>[0].Concat(referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty).Concat(new IReadOnlyList<string>[] { null }).Concat(referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty).ToList(),
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "collectionInterfaceOfReadOnlyListInterfaceOfStringProperty", "contains at least one null element", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'listInterfaceOfCollectionInterfaceOfStringProperty' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             null,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "listInterfaceOfCollectionInterfaceOfStringProperty", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'listInterfaceOfCollectionInterfaceOfStringProperty' is an empty enumerable scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             new List<ICollection<string>>(),
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "listInterfaceOfCollectionInterfaceOfStringProperty", "is an empty enumerable", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'listInterfaceOfCollectionInterfaceOfStringProperty' contains a null element scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             new ICollection<string>[0].Concat(referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty).Concat(new ICollection<string>[] { null }).Concat(referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty).ToList(),
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "listInterfaceOfCollectionInterfaceOfStringProperty", "contains at least one null element", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'readOnlyListInterfaceOfListInterfaceOfStringProperty' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             null,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "readOnlyListInterfaceOfListInterfaceOfStringProperty", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'readOnlyListInterfaceOfListInterfaceOfStringProperty' is an empty enumerable scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             new List<IList<string>>(),
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "readOnlyListInterfaceOfListInterfaceOfStringProperty", "is an empty enumerable", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'readOnlyListInterfaceOfListInterfaceOfStringProperty' contains a null element scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             new IList<string>[0].Concat(referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty).Concat(new IList<string>[] { null }).Concat(referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty).ToList(),
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "readOnlyListInterfaceOfListInterfaceOfStringProperty", "contains at least one null element", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'dictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             null,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "dictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'dictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty' is an empty dictionary scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             new Dictionary<string, IReadOnlyList<DateTime>>(),
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "dictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty", "is an empty dictionary", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'dictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty' contains a key-value pair with a null value scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var dictionaryWithNullValue = referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.ToDictionary(_ => _.Key, _ => _.Value);

                        var randomKey = dictionaryWithNullValue.Keys.ElementAt(ThreadSafeRandom.Next(0, dictionaryWithNullValue.Count));

                        dictionaryWithNullValue[randomKey] = null;

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             dictionaryWithNullValue,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "dictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty", "contains at least one key-value pair with a null value", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'readOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             null,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "readOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'readOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty' is an empty dictionary scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             new Dictionary<string, ICollection<DateTime>>(),
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "readOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty", "is an empty dictionary", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'readOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty' contains a key-value pair with a null value scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var dictionaryWithNullValue = referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty.ToDictionary(_ => _.Key, _ => _.Value);

                        var randomKey = dictionaryWithNullValue.Keys.ElementAt(ThreadSafeRandom.Next(0, dictionaryWithNullValue.Count));

                        dictionaryWithNullValue[randomKey] = null;

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             dictionaryWithNullValue,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "readOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty", "contains at least one key-value pair with a null value", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'readOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             null,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "readOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'readOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty' is an empty enumerable scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             new List<IReadOnlyDictionary<string, IReadOnlyList<DateTime>>>(),
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "readOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty", "is an empty enumerable", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'readOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty' contains a null element scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             new IReadOnlyDictionary<string, IReadOnlyList<DateTime>>[0].Concat(referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty).Concat(new IReadOnlyDictionary<string, IReadOnlyList<DateTime>>[] { null }).Concat(referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty).ToList(),
                                             referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "readOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty", "contains at least one null element", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'readOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             null);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "readOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'readOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty' is an empty dictionary scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             new Dictionary<string, IReadOnlyDictionary<string, IDictionary<CustomClass, IReadOnlyList<DateTime>>>>());

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "readOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty", "is an empty dictionary", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "constructor should throw ArgumentException when parameter 'readOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty' contains a key-value pair with a null value scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var dictionaryWithNullValue = referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.ToDictionary(_ => _.Key, _ => _.Value);

                        var randomKey = dictionaryWithNullValue.Keys.ElementAt(ThreadSafeRandom.Next(0, dictionaryWithNullValue.Count));

                        dictionaryWithNullValue[randomKey] = null;

                        var result = new ModelAllPrivateSetMisc(
                                             referenceObject.CollectionInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                             referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                             referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                             referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                             referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                             dictionaryWithNullValue);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "readOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty", "contains at least one key-value pair with a null value", },
                });

        private static readonly ConstructorPropertyAssignmentTestScenarios<ModelAllPrivateSetMisc> ConstructorPropertyAssignmentTestScenarios = new ConstructorPropertyAssignmentTestScenarios<ModelAllPrivateSetMisc>()
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "CollectionInterfaceOfStringProperty should return same 'collectionInterfaceOfStringProperty' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new SystemUnderTestExpectedPropertyValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = new ModelAllPrivateSetMisc(
                                                      referenceObject.CollectionInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                                      referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                            ExpectedPropertyValue = referenceObject.CollectionInterfaceOfStringProperty,
                        };

                        return result;
                    },
                    PropertyName = "CollectionInterfaceOfStringProperty",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "ListInterfaceOfStringProperty should return same 'listInterfaceOfStringProperty' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new SystemUnderTestExpectedPropertyValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = new ModelAllPrivateSetMisc(
                                                      referenceObject.CollectionInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                                      referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                            ExpectedPropertyValue = referenceObject.ListInterfaceOfStringProperty,
                        };

                        return result;
                    },
                    PropertyName = "ListInterfaceOfStringProperty",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty should return same 'readOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new SystemUnderTestExpectedPropertyValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = new ModelAllPrivateSetMisc(
                                                      referenceObject.CollectionInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                                      referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                            ExpectedPropertyValue = referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                        };

                        return result;
                    },
                    PropertyName = "ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty should return same 'collectionInterfaceOfReadOnlyListInterfaceOfStringProperty' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new SystemUnderTestExpectedPropertyValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = new ModelAllPrivateSetMisc(
                                                      referenceObject.CollectionInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                                      referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                            ExpectedPropertyValue = referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                        };

                        return result;
                    },
                    PropertyName = "CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "ListInterfaceOfCollectionInterfaceOfStringProperty should return same 'listInterfaceOfCollectionInterfaceOfStringProperty' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new SystemUnderTestExpectedPropertyValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = new ModelAllPrivateSetMisc(
                                                      referenceObject.CollectionInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                                      referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                            ExpectedPropertyValue = referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                        };

                        return result;
                    },
                    PropertyName = "ListInterfaceOfCollectionInterfaceOfStringProperty",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "ReadOnlyListInterfaceOfListInterfaceOfStringProperty should return same 'readOnlyListInterfaceOfListInterfaceOfStringProperty' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new SystemUnderTestExpectedPropertyValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = new ModelAllPrivateSetMisc(
                                                      referenceObject.CollectionInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                                      referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                            ExpectedPropertyValue = referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                        };

                        return result;
                    },
                    PropertyName = "ReadOnlyListInterfaceOfListInterfaceOfStringProperty",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty should return same 'dictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new SystemUnderTestExpectedPropertyValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = new ModelAllPrivateSetMisc(
                                                      referenceObject.CollectionInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                                      referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                            ExpectedPropertyValue = referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                        };

                        return result;
                    },
                    PropertyName = "DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty should return same 'readOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new SystemUnderTestExpectedPropertyValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = new ModelAllPrivateSetMisc(
                                                      referenceObject.CollectionInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                                      referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                            ExpectedPropertyValue = referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                        };

                        return result;
                    },
                    PropertyName = "ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty should return same 'readOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new SystemUnderTestExpectedPropertyValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = new ModelAllPrivateSetMisc(
                                                      referenceObject.CollectionInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                                      referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                            ExpectedPropertyValue = referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                        };

                        return result;
                    },
                    PropertyName = "ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty should return same 'readOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>();

                        var result = new SystemUnderTestExpectedPropertyValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = new ModelAllPrivateSetMisc(
                                                      referenceObject.CollectionInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                                      referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                                      referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                                      referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                            ExpectedPropertyValue = referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                        };

                        return result;
                    },
                    PropertyName = "ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty",
                });

        private static readonly DeepCloneWithTestScenarios<ModelAllPrivateSetMisc> DeepCloneWithTestScenarios = new DeepCloneWithTestScenarios<ModelAllPrivateSetMisc>()
            .AddScenario(() =>
                new DeepCloneWithTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "DeepCloneWithCollectionInterfaceOfStringProperty should deep clone object and replace CollectionInterfaceOfStringProperty with the provided collectionInterfaceOfStringProperty",
                    WithPropertyName = "CollectionInterfaceOfStringProperty",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<ModelAllPrivateSetMisc>();

                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>().ThatIs(_ => !systemUnderTest.CollectionInterfaceOfStringProperty.IsEqualTo(_.CollectionInterfaceOfStringProperty));

                        var result = new SystemUnderTestDeepCloneWithValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.CollectionInterfaceOfStringProperty,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "DeepCloneWithListInterfaceOfStringProperty should deep clone object and replace ListInterfaceOfStringProperty with the provided listInterfaceOfStringProperty",
                    WithPropertyName = "ListInterfaceOfStringProperty",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<ModelAllPrivateSetMisc>();

                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>().ThatIs(_ => !systemUnderTest.ListInterfaceOfStringProperty.IsEqualTo(_.ListInterfaceOfStringProperty));

                        var result = new SystemUnderTestDeepCloneWithValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.ListInterfaceOfStringProperty,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "DeepCloneWithReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty should deep clone object and replace ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty with the provided readOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty",
                    WithPropertyName = "ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<ModelAllPrivateSetMisc>();

                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>().ThatIs(_ => !systemUnderTest.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty.IsEqualTo(_.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty));

                        var result = new SystemUnderTestDeepCloneWithValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "DeepCloneWithCollectionInterfaceOfReadOnlyListInterfaceOfStringProperty should deep clone object and replace CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty with the provided collectionInterfaceOfReadOnlyListInterfaceOfStringProperty",
                    WithPropertyName = "CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<ModelAllPrivateSetMisc>();

                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>().ThatIs(_ => !systemUnderTest.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty.IsEqualTo(_.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty));

                        var result = new SystemUnderTestDeepCloneWithValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "DeepCloneWithListInterfaceOfCollectionInterfaceOfStringProperty should deep clone object and replace ListInterfaceOfCollectionInterfaceOfStringProperty with the provided listInterfaceOfCollectionInterfaceOfStringProperty",
                    WithPropertyName = "ListInterfaceOfCollectionInterfaceOfStringProperty",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<ModelAllPrivateSetMisc>();

                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>().ThatIs(_ => !systemUnderTest.ListInterfaceOfCollectionInterfaceOfStringProperty.IsEqualTo(_.ListInterfaceOfCollectionInterfaceOfStringProperty));

                        var result = new SystemUnderTestDeepCloneWithValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.ListInterfaceOfCollectionInterfaceOfStringProperty,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "DeepCloneWithReadOnlyListInterfaceOfListInterfaceOfStringProperty should deep clone object and replace ReadOnlyListInterfaceOfListInterfaceOfStringProperty with the provided readOnlyListInterfaceOfListInterfaceOfStringProperty",
                    WithPropertyName = "ReadOnlyListInterfaceOfListInterfaceOfStringProperty",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<ModelAllPrivateSetMisc>();

                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>().ThatIs(_ => !systemUnderTest.ReadOnlyListInterfaceOfListInterfaceOfStringProperty.IsEqualTo(_.ReadOnlyListInterfaceOfListInterfaceOfStringProperty));

                        var result = new SystemUnderTestDeepCloneWithValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "DeepCloneWithDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty should deep clone object and replace DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty with the provided dictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty",
                    WithPropertyName = "DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<ModelAllPrivateSetMisc>();

                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>().ThatIs(_ => !systemUnderTest.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.IsEqualTo(_.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty));

                        var result = new SystemUnderTestDeepCloneWithValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "DeepCloneWithReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty should deep clone object and replace ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty with the provided readOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty",
                    WithPropertyName = "ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<ModelAllPrivateSetMisc>();

                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>().ThatIs(_ => !systemUnderTest.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty.IsEqualTo(_.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty));

                        var result = new SystemUnderTestDeepCloneWithValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "DeepCloneWithReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty should deep clone object and replace ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty with the provided readOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty",
                    WithPropertyName = "ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<ModelAllPrivateSetMisc>();

                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>().ThatIs(_ => !systemUnderTest.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.IsEqualTo(_.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty));

                        var result = new SystemUnderTestDeepCloneWithValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "DeepCloneWithReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty should deep clone object and replace ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty with the provided readOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty",
                    WithPropertyName = "ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<ModelAllPrivateSetMisc>();

                        var referenceObject = A.Dummy<ModelAllPrivateSetMisc>().ThatIs(_ => !systemUnderTest.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.IsEqualTo(_.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty));

                        var result = new SystemUnderTestDeepCloneWithValue<ModelAllPrivateSetMisc>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                        };

                        return result;
                    },
                });

        private static readonly ModelAllPrivateSetMisc ReferenceObjectForEquatableTestScenarios = A.Dummy<ModelAllPrivateSetMisc>();

        private static readonly EquatableTestScenarios<ModelAllPrivateSetMisc> EquatableTestScenarios = new EquatableTestScenarios<ModelAllPrivateSetMisc>()
            .AddScenario(() =>
                new EquatableTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "Default Code Generated Scenario",
                    ReferenceObject = ReferenceObjectForEquatableTestScenarios,
                    ObjectsThatAreEqualToButNotTheSameAsReferenceObject = new ModelAllPrivateSetMisc[]
                    {
                        new ModelAllPrivateSetMisc(
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                    },
                    ObjectsThatAreNotEqualToReferenceObject = new ModelAllPrivateSetMisc[]
                    {
                        new ModelAllPrivateSetMisc(
                                A.Dummy<ModelAllPrivateSetMisc>().Whose(_ => !_.CollectionInterfaceOfStringProperty.IsEqualTo(ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfStringProperty)).CollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                        new ModelAllPrivateSetMisc(
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfStringProperty,
                                A.Dummy<ModelAllPrivateSetMisc>().Whose(_ => !_.ListInterfaceOfStringProperty.IsEqualTo(ReferenceObjectForEquatableTestScenarios.ListInterfaceOfStringProperty)).ListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                        new ModelAllPrivateSetMisc(
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfStringProperty,
                                A.Dummy<ModelAllPrivateSetMisc>().Whose(_ => !_.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty.IsEqualTo(ReferenceObjectForEquatableTestScenarios.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty)).ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                        new ModelAllPrivateSetMisc(
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                A.Dummy<ModelAllPrivateSetMisc>().Whose(_ => !_.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty.IsEqualTo(ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty)).CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                        new ModelAllPrivateSetMisc(
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                A.Dummy<ModelAllPrivateSetMisc>().Whose(_ => !_.ListInterfaceOfCollectionInterfaceOfStringProperty.IsEqualTo(ReferenceObjectForEquatableTestScenarios.ListInterfaceOfCollectionInterfaceOfStringProperty)).ListInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                        new ModelAllPrivateSetMisc(
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                A.Dummy<ModelAllPrivateSetMisc>().Whose(_ => !_.ReadOnlyListInterfaceOfListInterfaceOfStringProperty.IsEqualTo(ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfListInterfaceOfStringProperty)).ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                        new ModelAllPrivateSetMisc(
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                A.Dummy<ModelAllPrivateSetMisc>().Whose(_ => !_.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.IsEqualTo(ReferenceObjectForEquatableTestScenarios.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty)).DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                        new ModelAllPrivateSetMisc(
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                A.Dummy<ModelAllPrivateSetMisc>().Whose(_ => !_.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty.IsEqualTo(ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty)).ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                        new ModelAllPrivateSetMisc(
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                A.Dummy<ModelAllPrivateSetMisc>().Whose(_ => !_.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.IsEqualTo(ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty)).ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                        new ModelAllPrivateSetMisc(
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ListInterfaceOfCollectionInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfListInterfaceOfStringProperty,
                                ReferenceObjectForEquatableTestScenarios.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty,
                                ReferenceObjectForEquatableTestScenarios.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty,
                                A.Dummy<ModelAllPrivateSetMisc>().Whose(_ => !_.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.IsEqualTo(ReferenceObjectForEquatableTestScenarios.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty)).ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty),
                    },
                    ObjectsThatAreNotOfTheSameTypeAsReferenceObject = new object[]
                    {
                        A.Dummy<object>(),
                        A.Dummy<string>(),
                        A.Dummy<int>(),
                        A.Dummy<int?>(),
                        A.Dummy<Guid>(),
                    },
                });

        private static readonly ValidModelTestScenarios<ModelAllPrivateSetMisc> ValidModelTestScenarios = new ValidModelTestScenarios<ModelAllPrivateSetMisc>()
            .AddScenario(() =>
                new ValidModelTestScenario<ModelAllPrivateSetMisc>
                {
                    Name = "a dummy ModelAllPrivateSetMisc should be valid",
                    SystemUnderTest = A.Dummy<ModelAllPrivateSetMisc>(),
                });

        [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        [SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
        public static class StructuralTesting
        {
            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void ModelAllPrivateSetMisc___Should_implement_IModel_of_ModelAllPrivateSetMisc___When_reflecting()
            {
                // Arrange
                var type = typeof(ModelAllPrivateSetMisc);

                var expectedModelMethods = typeof(IModel<ModelAllPrivateSetMisc>).GetInterfaceDeclaredAndImplementedMethods();

                var expectedModelMethodHashes = expectedModelMethods.Select(_ => _.GetSignatureHash());

                // Act
                var actualInterfaces = type.GetInterfaces();
                var actualModelMethods = type.GetMethodsFiltered(MemberRelationships.DeclaredOrInherited, MemberOwners.Instance, MemberAccessModifiers.Public).ToList();
                var actualModelMethodHashes = actualModelMethods.Select(_ => _.GetSignatureHash());

                // Assert
                actualInterfaces.AsTest().Must().ContainElement(typeof(IModel<ModelAllPrivateSetMisc>));
                expectedModelMethodHashes.Except(actualModelMethodHashes).AsTest().Must().BeEmptyEnumerable();
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void ModelAllPrivateSetMisc___Should_be_attributed_with_Serializable____When_reflecting()
            {
                // Arrange
                var type = typeof(ModelAllPrivateSetMisc);

                // Act
                var actualAttributes = type.GetCustomAttributes(typeof(SerializableAttribute), false);

                // Assert
                actualAttributes.AsTest().Must().NotBeEmptyEnumerable();
            }
        }

        [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        [SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
        public static class StringRepresentationTesting
        {
            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void ToString___Should_generate_friendly_string_representation_of_object___When_called()
            {
                var scenarios = StringRepresentationTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actual = scenario.SystemUnderTest.ToString();

                    // Assert
                    actual.AsTest().Must().BeEqualTo(scenario.ExpectedStringRepresentation, because: scenario.Id);
                }
            }
        }

        [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        [SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
        public static class ConstructionTesting
        {
            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Constructor___Should_throw___When_parameters_are_not_valid()
            {
                var scenarios = ConstructorArgumentValidationTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actual = Record.Exception(scenario.ConstructionFunc);

                    // Assert
                    actual.AsTest().Must().BeOfType(scenario.ExpectedExceptionType, because: scenario.Id);

                    foreach (var expected in scenario.ExpectedExceptionMessageContains ?? new List<string>())
                    {
                        actual.Message.AsTest().Must().ContainString(expected, because: scenario.Id);
                    }

                    if (scenario.ExpectedExceptionMessageEquals != null)
                    {
                        actual.Message.AsTest().Must().BeEqualTo(scenario.ExpectedExceptionMessageEquals, because: scenario.Id);
                    }
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "referenceObject")]
            public static void Properties___Should_be_assigned_by_constructor_to_expected_value___When_getting()
            {
                var scenarios = ConstructorPropertyAssignmentTestScenarios.ValidateAndPrepareForTesting();

                var asTestMethodInfo = typeof(WorkflowExtensions).GetMethodFiltered(nameof(WorkflowExtensions.AsTest));

                var beEqualToMethodInfo = typeof(Verifications).GetMethodFiltered(nameof(Verifications.BeEqualTo));

                foreach (var scenario in scenarios)
                {
                    // Arrange
                    if ((scenario.PropertyName == ConstructorPropertyAssignmentTestScenario.NoPropertiesAssignedInConstructorScenarioPropertyName) || (scenario.PropertyName == ConstructorPropertyAssignmentTestScenario.ForceGeneratedTestsToPassAndWriteMyOwnScenarioPropertyName))
                    {
                        continue;
                    }

                    // Act
                    var actual = scenario.Property.GetValue(scenario.SystemUnderTest);

                    // Assert
                    // When the scenario specifies CompareActualToExpectedUsing.DefaultStrategy, ValidateAndPrepareForTesting()
                    // will check if ExpectedPropertyValue == null.  If so, it sets CompareActualToExpectedUsing = ReferenceEquality.
                    // If not, then it checks the runtime type of ExpectedPropertyValue and if it's a value type,
                    // then it sets CompareActualToExpectedUsing = ValueEquality, otherwise it uses ValueEquality.
                    // So a boxed value type is handled properly (using ValueEquality instead of ReferenceEquality).
                    if (scenario.CompareActualToExpectedUsing == CompareActualToExpectedUsing.ValueEquality)
                    {
                        // The below reflection code is used in lieu of the following single line of code
                        // so that equality is determined based on the property type instead of using
                        // OBeautifulCode.Equality.Recipes.ObjectEqualityComparer, which will return false
                        // when the objects being compared have different runtime types.  For example, if
                        // the property type is IReadOnlyCollection<string> and we are comparing an empty array
                        // an empty List, the assertion below would fail inappropriately.
                        // actual.AsTest().Must().BeEqualTo(scenario.ExpectedPropertyValue, because: scenario.Id);

                        var propertyType = scenario.Property.PropertyType;

                        var asTestMethodInfoToInvoke = asTestMethodInfo.MakeGenericMethod(propertyType);

                        var assertionTracker = asTestMethodInfoToInvoke.Invoke(null, new[] { actual, Type.Missing });

                        assertionTracker.Must();

                        var mustBeEqualToMethodInfoToInvoke = beEqualToMethodInfo.MakeGenericMethod(propertyType);

                        mustBeEqualToMethodInfoToInvoke.Invoke(null, new[] { assertionTracker, scenario.ExpectedPropertyValue, scenario.Id, Type.Missing, Type.Missing });
                    }
                    else if (scenario.CompareActualToExpectedUsing == CompareActualToExpectedUsing.ReferenceEquality)
                    {
                        actual.AsTest().Must().BeSameReferenceAs(scenario.ExpectedPropertyValue, because: scenario.Id);
                    }
                    else
                    {
                        throw new NotSupportedException("This CompareActualToExpectedUsing is not supported: " + scenario.CompareActualToExpectedUsing);
                    }
                }
            }
        }

        [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        [SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
        public static class CloningTesting
        {
            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Clone___Should_clone_object___When_called()
            {
                // Arrange
                var systemUnderTest = A.Dummy<ModelAllPrivateSetMisc>();

                // Act
                var actual = (ModelAllPrivateSetMisc)systemUnderTest.Clone();

                // Assert
                actual.AsTest().Must().BeEqualTo(systemUnderTest);
                actual.AsTest().Must().NotBeSameReferenceAs(systemUnderTest);
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void DeepClone___Should_deep_clone_object___When_called()
            {
                // Arrange
                var systemUnderTest = A.Dummy<ModelAllPrivateSetMisc>();

                // Act
                var actual = systemUnderTest.DeepClone();

                // Assert
                actual.AsTest().Must().BeEqualTo(systemUnderTest);
                actual.AsTest().Must().NotBeSameReferenceAs(systemUnderTest);

                if (systemUnderTest.CollectionInterfaceOfStringProperty == null)
                {
                    actual.CollectionInterfaceOfStringProperty.AsTest().Must().BeNull();
                }
                else if (!actual.CollectionInterfaceOfStringProperty.GetType().IsValueType)
                {
                    // When the declared type is a reference type, we still have to check the runtime type.
                    // The object could be a boxed value type, which will fail this asseration because
                    // a deep clone of a value type object is the same object.
                    actual.CollectionInterfaceOfStringProperty.AsTest().Must().NotBeSameReferenceAs(systemUnderTest.CollectionInterfaceOfStringProperty);
                }

                if (systemUnderTest.ListInterfaceOfStringProperty == null)
                {
                    actual.ListInterfaceOfStringProperty.AsTest().Must().BeNull();
                }
                else if (!actual.ListInterfaceOfStringProperty.GetType().IsValueType)
                {
                    // When the declared type is a reference type, we still have to check the runtime type.
                    // The object could be a boxed value type, which will fail this asseration because
                    // a deep clone of a value type object is the same object.
                    actual.ListInterfaceOfStringProperty.AsTest().Must().NotBeSameReferenceAs(systemUnderTest.ListInterfaceOfStringProperty);
                }

                if (systemUnderTest.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty == null)
                {
                    actual.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty.AsTest().Must().BeNull();
                }
                else if (!actual.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty.GetType().IsValueType)
                {
                    // When the declared type is a reference type, we still have to check the runtime type.
                    // The object could be a boxed value type, which will fail this asseration because
                    // a deep clone of a value type object is the same object.
                    actual.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty.AsTest().Must().NotBeSameReferenceAs(systemUnderTest.ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty);
                }

                if (systemUnderTest.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty == null)
                {
                    actual.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty.AsTest().Must().BeNull();
                }
                else if (!actual.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty.GetType().IsValueType)
                {
                    // When the declared type is a reference type, we still have to check the runtime type.
                    // The object could be a boxed value type, which will fail this asseration because
                    // a deep clone of a value type object is the same object.
                    actual.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty.AsTest().Must().NotBeSameReferenceAs(systemUnderTest.CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty);
                }

                if (systemUnderTest.ListInterfaceOfCollectionInterfaceOfStringProperty == null)
                {
                    actual.ListInterfaceOfCollectionInterfaceOfStringProperty.AsTest().Must().BeNull();
                }
                else if (!actual.ListInterfaceOfCollectionInterfaceOfStringProperty.GetType().IsValueType)
                {
                    // When the declared type is a reference type, we still have to check the runtime type.
                    // The object could be a boxed value type, which will fail this asseration because
                    // a deep clone of a value type object is the same object.
                    actual.ListInterfaceOfCollectionInterfaceOfStringProperty.AsTest().Must().NotBeSameReferenceAs(systemUnderTest.ListInterfaceOfCollectionInterfaceOfStringProperty);
                }

                if (systemUnderTest.ReadOnlyListInterfaceOfListInterfaceOfStringProperty == null)
                {
                    actual.ReadOnlyListInterfaceOfListInterfaceOfStringProperty.AsTest().Must().BeNull();
                }
                else if (!actual.ReadOnlyListInterfaceOfListInterfaceOfStringProperty.GetType().IsValueType)
                {
                    // When the declared type is a reference type, we still have to check the runtime type.
                    // The object could be a boxed value type, which will fail this asseration because
                    // a deep clone of a value type object is the same object.
                    actual.ReadOnlyListInterfaceOfListInterfaceOfStringProperty.AsTest().Must().NotBeSameReferenceAs(systemUnderTest.ReadOnlyListInterfaceOfListInterfaceOfStringProperty);
                }

                if (systemUnderTest.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty == null)
                {
                    actual.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.AsTest().Must().BeNull();
                }
                else if (!actual.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.GetType().IsValueType)
                {
                    // When the declared type is a reference type, we still have to check the runtime type.
                    // The object could be a boxed value type, which will fail this asseration because
                    // a deep clone of a value type object is the same object.
                    actual.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.AsTest().Must().NotBeSameReferenceAs(systemUnderTest.DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);
                }

                if (systemUnderTest.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty == null)
                {
                    actual.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty.AsTest().Must().BeNull();
                }
                else if (!actual.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty.GetType().IsValueType)
                {
                    // When the declared type is a reference type, we still have to check the runtime type.
                    // The object could be a boxed value type, which will fail this asseration because
                    // a deep clone of a value type object is the same object.
                    actual.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty.AsTest().Must().NotBeSameReferenceAs(systemUnderTest.ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty);
                }

                if (systemUnderTest.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty == null)
                {
                    actual.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.AsTest().Must().BeNull();
                }
                else if (!actual.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.GetType().IsValueType)
                {
                    // When the declared type is a reference type, we still have to check the runtime type.
                    // The object could be a boxed value type, which will fail this asseration because
                    // a deep clone of a value type object is the same object.
                    actual.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.AsTest().Must().NotBeSameReferenceAs(systemUnderTest.ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);
                }

                if (systemUnderTest.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty == null)
                {
                    actual.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.AsTest().Must().BeNull();
                }
                else if (!actual.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.GetType().IsValueType)
                {
                    // When the declared type is a reference type, we still have to check the runtime type.
                    // The object could be a boxed value type, which will fail this asseration because
                    // a deep clone of a value type object is the same object.
                    actual.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty.AsTest().Must().NotBeSameReferenceAs(systemUnderTest.ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void DeepCloneWith___Should_deep_clone_object_and_replace_the_associated_property_with_the_provided_value___When_called()
            {
                var propertyNames = new string[] { "CollectionInterfaceOfStringProperty", "ListInterfaceOfStringProperty", "ReadOnlyCollectionInterfaceOfCollectionInterfaceOfStringProperty", "CollectionInterfaceOfReadOnlyListInterfaceOfStringProperty", "ListInterfaceOfCollectionInterfaceOfStringProperty", "ReadOnlyListInterfaceOfListInterfaceOfStringProperty", "DictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty", "ReadOnlyDictionaryInterfaceOfCollectionInterfaceOfDateTimeProperty", "ReadOnlyListInterfaceOfReadOnlyDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty", "ReadOnlyDictionaryInterfaceOfReadOnlyDictionaryInterfaceOfDictionaryInterfaceOfReadOnlyListInterfaceOfDateTimeProperty" };

                var scenarios = DeepCloneWithTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange
                    if (scenario.WithPropertyName == DeepCloneWithTestScenario.ForceGeneratedTestsToPassAndWriteMyOwnScenarioWithPropertyName)
                    {
                        continue;
                    }

                    // Act
                    var actual = (ModelAllPrivateSetMisc)scenario.DeepCloneWithMethod.Invoke(scenario.SystemUnderTest, new[] { scenario.WithValue });

                    // Assert
                    foreach (var propertyName in propertyNames)
                    {
                        var propertyInfo = typeof(ModelAllPrivateSetMisc).GetPropertyFiltered(propertyName, MemberRelationships.DeclaredOrInherited, MemberOwners.Instance, MemberAccessModifiers.Public);

                        var actualPropertyValue = propertyInfo.GetValue(actual);

                        var comparisonValue = propertyName == scenario.WithPropertyName
                            ? scenario.WithValue
                            : propertyInfo.GetValue(scenario.SystemUnderTest);

                        if (actualPropertyValue == null)
                        {
                            comparisonValue.Must().BeNull(because: scenario.Id);
                        }
                        else
                        {
                            // We use the runtime type here to solve for the case where the object is a boxed value type.
                            var actualPropertyValueRuntimeType = actualPropertyValue.GetType();

                            if (actualPropertyValueRuntimeType.IsValueType || (actualPropertyValueRuntimeType == typeof(string)))
                            {
                                // actualPropertyValue and comparisonValue are declared as typeof(object), but
                                // BeEqualTo (which uses IsEqualTo), will do the right thing by comparing the
                                // objects using their runtime type.
                                actualPropertyValue.AsTest().Must().BeEqualTo(comparisonValue, because: scenario.Id);
                            }
                            else
                            {
                                if (propertyName == scenario.WithPropertyName)
                                {
                                    actualPropertyValue.AsTest().Must().BeSameReferenceAs(comparisonValue, because: scenario.Id);
                                }
                                else
                                {
                                    actualPropertyValue.AsTest().Must().NotBeSameReferenceAs(comparisonValue, because: scenario.Id);
                                }
                            }
                        }
                    }
                }
            }
        }

        [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        [SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
        public static class SerializationTesting
        {
            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Deserialize___Should_roundtrip_object___When_serializing_to_and_deserializing_from_string_using_ObcBsonSerializer()
            {
                // Arrange
                var expected = A.Dummy<ModelAllPrivateSetMisc>();

                var serializationConfigurationType = SerializationConfigurationTypes.BsonSerializationConfigurationType.ConcreteSerializationConfigurationDerivativeType;

                var serializationFormats = new[] { SerializationFormat.String };

                var appDomainScenarios = AppDomainScenarios.RoundtripInCurrentAppDomain | AppDomainScenarios.SerializeInCurrentAppDomainAndDeserializeInNewAppDomain;

                // Act, Assert
                expected.RoundtripSerializeViaBsonWithBeEqualToAssertion(serializationConfigurationType, serializationFormats, appDomainScenarios);
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Deserialize___Should_roundtrip_object___When_serializing_to_and_deserializing_from_bytes_using_ObcBsonSerializer()
            {
                // Arrange
                var expected = A.Dummy<ModelAllPrivateSetMisc>();

                var serializationConfigurationType = SerializationConfigurationTypes.BsonSerializationConfigurationType.ConcreteSerializationConfigurationDerivativeType;

                var serializationFormats = new[] { SerializationFormat.Binary };

                var appDomainScenarios = AppDomainScenarios.RoundtripInCurrentAppDomain | AppDomainScenarios.SerializeInCurrentAppDomainAndDeserializeInNewAppDomain;

                // Act, Assert
                expected.RoundtripSerializeViaBsonWithBeEqualToAssertion(serializationConfigurationType, serializationFormats, appDomainScenarios);
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Deserialize___Should_roundtrip_object___When_serializing_to_and_deserializing_from_string_using_ObcJsonSerializer()
            {
                // Arrange
                var expected = A.Dummy<ModelAllPrivateSetMisc>();

                var serializationConfigurationType = SerializationConfigurationTypes.JsonSerializationConfigurationType.ConcreteSerializationConfigurationDerivativeType;

                var serializationFormats = new[] { SerializationFormat.String };

                var appDomainScenarios = AppDomainScenarios.RoundtripInCurrentAppDomain | AppDomainScenarios.SerializeInCurrentAppDomainAndDeserializeInNewAppDomain;

                // Act, Assert
                expected.RoundtripSerializeViaJsonWithBeEqualToAssertion(serializationConfigurationType, serializationFormats, appDomainScenarios);
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Deserialize___Should_roundtrip_object___When_serializing_to_and_deserializing_from_bytes_using_ObcJsonSerializer()
            {
                // Arrange
                var expected = A.Dummy<ModelAllPrivateSetMisc>();

                var serializationConfigurationType = SerializationConfigurationTypes.JsonSerializationConfigurationType.ConcreteSerializationConfigurationDerivativeType;

                var serializationFormats = new[] { SerializationFormat.Binary };

                var appDomainScenarios = AppDomainScenarios.RoundtripInCurrentAppDomain | AppDomainScenarios.SerializeInCurrentAppDomainAndDeserializeInNewAppDomain;

                // Act, Assert
                expected.RoundtripSerializeViaJsonWithBeEqualToAssertion(serializationConfigurationType, serializationFormats, appDomainScenarios);
            }
        }

        [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        [SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
        public static class EqualityTesting
        {
            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void EqualsOperator___Should_return_true___When_both_sides_of_operator_are_null()
            {
                // Arrange
                ModelAllPrivateSetMisc systemUnderTest1 = null;
                ModelAllPrivateSetMisc systemUnderTest2 = null;

                // Act
                var actual = systemUnderTest1 == systemUnderTest2;

                // Assert
                actual.AsTest().Must().BeTrue();
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void EqualsOperator___Should_return_false___When_one_side_of_operator_is_null_and_the_other_side_is_not_null()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange
                    ModelAllPrivateSetMisc systemUnderTest = null;

                    // Act
                    var actual1 = systemUnderTest == scenario.ReferenceObject;
                    var actual2 = scenario.ReferenceObject == systemUnderTest;

                    // Assert
                    actual1.AsTest().Must().BeFalse(because: scenario.Id);
                    actual2.AsTest().Must().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void EqualsOperator___Should_return_true___When_same_object_is_on_both_sides_of_operator()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    #pragma warning disable CS1718 // Comparison made to same variable
                    var actual = scenario.ReferenceObject == scenario.ReferenceObject;
                    #pragma warning restore CS1718 // Comparison made to same variable

                    // Assert
                    actual.AsTest().Must().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void EqualsOperator___Should_return_false___When_objects_being_compared_derive_from_the_same_type_but_are_not_of_the_same_type()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals1 = scenario.ObjectsThatDeriveFromScenarioTypeButAreNotOfTheSameTypeAsReferenceObject.Select(_ => scenario.ReferenceObject == _).ToList();
                    var actuals2 = scenario.ObjectsThatDeriveFromScenarioTypeButAreNotOfTheSameTypeAsReferenceObject.Select(_ => _ == scenario.ReferenceObject).ToList();

                    // Assert
                    actuals1.AsTest().Must().Each().BeFalse(because: scenario.Id);
                    actuals2.AsTest().Must().Each().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void EqualsOperator___Should_return_false___When_objects_being_compared_have_different_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals1 = scenario.ObjectsThatAreNotEqualToReferenceObject.Select(_ => scenario.ReferenceObject == _).ToList();
                    var actuals2 = scenario.ObjectsThatAreNotEqualToReferenceObject.Select(_ => _ == scenario.ReferenceObject).ToList();

                    // Assert
                    actuals1.AsTest().Must().Each().BeFalse(because: scenario.Id);
                    actuals2.AsTest().Must().Each().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void EqualsOperator___Should_return_true___When_objects_being_compared_have_same_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals1 = scenario.ObjectsThatAreEqualToButNotTheSameAsReferenceObject.Select(_ => scenario.ReferenceObject == _).ToList();
                    var actuals2 = scenario.ObjectsThatAreEqualToButNotTheSameAsReferenceObject.Select(_ => _ == scenario.ReferenceObject).ToList();

                    // Assert
                    actuals1.AsTest().Must().Each().BeTrue(because: scenario.Id);
                    actuals2.AsTest().Must().Each().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void NotEqualsOperator___Should_return_false___When_both_sides_of_operator_are_null()
            {
                // Arrange
                ModelAllPrivateSetMisc systemUnderTest1 = null;
                ModelAllPrivateSetMisc systemUnderTest2 = null;

                // Act
                var actual = systemUnderTest1 != systemUnderTest2;

                // Assert
                actual.AsTest().Must().BeFalse();
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void NotEqualsOperator___Should_return_true___When_one_side_of_operator_is_null_and_the_other_side_is_not_null()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange
                    ModelAllPrivateSetMisc systemUnderTest = null;

                    // Act
                    var actual1 = systemUnderTest != scenario.ReferenceObject;
                    var actual2 = scenario.ReferenceObject != systemUnderTest;

                    // Assert
                    actual1.AsTest().Must().BeTrue(because: scenario.Id);
                    actual2.AsTest().Must().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void NotEqualsOperator___Should_return_false___When_same_object_is_on_both_sides_of_operator()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    #pragma warning disable CS1718 // Comparison made to same variable
                    var actual = scenario.ReferenceObject != scenario.ReferenceObject;
                    #pragma warning restore CS1718 // Comparison made to same variable

                    // Assert
                    actual.AsTest().Must().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void NotEqualsOperator___Should_return_true___When_objects_being_compared_derive_from_the_same_type_but_are_not_of_the_same_type()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals1 = scenario.ObjectsThatDeriveFromScenarioTypeButAreNotOfTheSameTypeAsReferenceObject.Select(_ => scenario.ReferenceObject != _).ToList();
                    var actuals2 = scenario.ObjectsThatDeriveFromScenarioTypeButAreNotOfTheSameTypeAsReferenceObject.Select(_ => _ != scenario.ReferenceObject).ToList();

                    // Assert
                    actuals1.AsTest().Must().Each().BeTrue(because: scenario.Id);
                    actuals2.AsTest().Must().Each().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void NotEqualsOperator___Should_return_true___When_objects_being_compared_have_different_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals1 = scenario.ObjectsThatAreNotEqualToReferenceObject.Select(_ => scenario.ReferenceObject != _).ToList();
                    var actuals2 = scenario.ObjectsThatAreNotEqualToReferenceObject.Select(_ => _ != scenario.ReferenceObject).ToList();

                    // Assert
                    actuals1.AsTest().Must().Each().BeTrue(because: scenario.Id);
                    actuals2.AsTest().Must().Each().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void NotEqualsOperator___Should_return_false___When_objects_being_compared_have_same_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals1 = scenario.ObjectsThatAreEqualToButNotTheSameAsReferenceObject.Select(_ => scenario.ReferenceObject != _).ToList();
                    var actuals2 = scenario.ObjectsThatAreEqualToButNotTheSameAsReferenceObject.Select(_ => _ != scenario.ReferenceObject).ToList();

                    // Assert
                    actuals1.AsTest().Must().Each().BeFalse(because: scenario.Id);
                    actuals2.AsTest().Must().Each().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_ModelAllPrivateSetMisc___Should_return_false___When_parameter_other_is_null()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange
                    ModelAllPrivateSetMisc systemUnderTest = null;

                    // Act
                    var actual = scenario.ReferenceObject.Equals(systemUnderTest);

                    // Assert
                    actual.AsTest().Must().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_ModelAllPrivateSetMisc___Should_return_true___When_parameter_other_is_same_object()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actual = scenario.ReferenceObject.Equals(scenario.ReferenceObject);

                    // Assert
                    actual.AsTest().Must().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_ModelAllPrivateSetMisc___Should_return_false___When_parameter_other_is_derived_from_the_same_type_but_is_not_of_the_same_type_as_this_object()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals = scenario.ObjectsThatDeriveFromScenarioTypeButAreNotOfTheSameTypeAsReferenceObject.Select(_ => scenario.ReferenceObject.Equals(_)).ToList();

                    // Assert
                    actuals.AsTest().Must().Each().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_ModelAllPrivateSetMisc___Should_return_false___When_objects_being_compared_have_different_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals = scenario.ObjectsThatAreNotEqualToReferenceObject.Select(_ => scenario.ReferenceObject.Equals(_)).ToList();

                    // Assert
                    actuals.AsTest().Must().Each().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_ModelAllPrivateSetMisc___Should_return_true___When_objects_being_compared_have_same_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals = scenario.ObjectsThatAreEqualToButNotTheSameAsReferenceObject.Select(_ => scenario.ReferenceObject.Equals(_)).ToList();

                    // Assert
                    actuals.AsTest().Must().Each().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_Object___Should_return_false___When_parameter_other_is_null()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actual = scenario.ReferenceObject.Equals((object)null);

                    // Assert
                    actual.AsTest().Must().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_Object___Should_return_false___When_parameter_other_is_not_of_the_same_type()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals1 = scenario.ObjectsThatDeriveFromScenarioTypeButAreNotOfTheSameTypeAsReferenceObject.Select(_ => scenario.ReferenceObject.Equals((object)_)).ToList();
                    var actuals2 = scenario.ObjectsThatAreNotOfTheSameTypeAsReferenceObject.Select(_ => scenario.ReferenceObject.Equals((object)_)).ToList();

                    // Assert
                    actuals1.AsTest().Must().Each().BeFalse(because: scenario.Id);
                    actuals2.AsTest().Must().Each().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_Object___Should_return_true___When_parameter_other_is_same_object()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actual = scenario.ReferenceObject.Equals((object)scenario.ReferenceObject);

                    // Assert
                    actual.AsTest().Must().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_Object___Should_return_false___When_objects_being_compared_have_different_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals = scenario.ObjectsThatAreNotEqualToReferenceObject.Select(_ => scenario.ReferenceObject.Equals((object)_)).ToList();

                    // Assert
                    actuals.AsTest().Must().Each().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_Object___Should_return_true___When_objects_being_compared_have_same_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals = scenario.ObjectsThatAreEqualToButNotTheSameAsReferenceObject.Select(_ => scenario.ReferenceObject.Equals((object)_)).ToList();

                    // Assert
                    actuals.AsTest().Must().Each().BeTrue(because: scenario.Id);
                }
            }
        }

        [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        [SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
        public static class HashTesting
        {
            [Fact(Skip = "It's possible (and even probable after a few runs of this test) that two dummy, unequal models will have the same hash code.  The model being tested contains at least one property who's type (or a type nested within the generic type, or a property of the IModel type) is a dictionary with keys that are not comparable or an unordered collection with elements that are not comparable.  In these cases the hashing method cannot hash the elements and must resort to hashing the element count.  Two dummies could easily have the same element count for such a type.")]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void GetHashCode___Should_not_be_equal_for_two_objects___When_objects_have_different_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var unexpected = scenario.ReferenceObject.GetHashCode();

                    var actuals = scenario.ObjectsThatAreNotEqualToReferenceObject.Select(_ => _.GetHashCode()).ToList();

                    // Assert
                    actuals.AsTest().Must().NotContainElement(unexpected, because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void GetHashCode___Should_be_equal_for_two_objects___When_objects_have_the_same_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var expected = scenario.ReferenceObject.GetHashCode();

                    var actuals = scenario.ObjectsThatAreEqualToButNotTheSameAsReferenceObject.Select(_ => _.GetHashCode()).ToList();

                    // Assert
                    actuals.AsTest().Must().Each().BeEqualTo(expected, because: scenario.Id);
                }
            }
        }

        [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        [SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
        public static class ValidationTesting
        {
            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void GetValidationFailures___Should_return_empty_list___When_model_is_valid()
            {
                var scenarios = ValidModelTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actual = scenario.SystemUnderTest.GetValidationFailures();

                    // Assert
                    actual.AsTest().Must().BeEmptyEnumerable(because: scenario.Id);
                }
            }
        }
    }
}