// --------------------------------------------------------------------------------------------------------------------
// <auto-generated>
//   Generated using OBeautifulCode.CodeGen.ModelObject (1.0.0.0)
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.CodeGen.ModelObject.Test
{
    using global::System;
    using global::System.CodeDom.Compiler;
    using global::System.Collections.Concurrent;
    using global::System.Collections.Generic;
    using global::System.Collections.ObjectModel;
    using global::System.Diagnostics.CodeAnalysis;
    using global::System.Globalization;
    using global::System.Linq;

    using global::OBeautifulCode.Cloning.Recipes;
    using global::OBeautifulCode.Equality.Recipes;
    using global::OBeautifulCode.Type;
    using global::OBeautifulCode.Type.Recipes;

    using static global::System.FormattableString;

    [Serializable]
    public partial class ModelPrivateSetGeneric<TFirst, TSecond> : IModel<ModelPrivateSetGeneric<TFirst, TSecond>>, IComparableForRelativeSortOrder<ModelPrivateSetGeneric<TFirst, TSecond>>
    {
        /// <summary>
        /// Determines whether two objects of type <see cref="ModelPrivateSetGeneric{TFirst, TSecond}"/> are equal.
        /// </summary>
        /// <param name="left">The object to the left of the equality operator.</param>
        /// <param name="right">The object to the right of the equality operator.</param>
        /// <returns>true if the two items are equal; otherwise false.</returns>
        public static bool operator ==(ModelPrivateSetGeneric<TFirst, TSecond> left, ModelPrivateSetGeneric<TFirst, TSecond> right)
        {
            if (ReferenceEquals(left, right))
            {
                return true;
            }

            if (ReferenceEquals(left, null) || ReferenceEquals(right, null))
            {
                return false;
            }

            var result = left.Equals(right);

            return result;
        }

        /// <summary>
        /// Determines whether two objects of type <see cref="ModelPrivateSetGeneric{TFirst, TSecond}"/> are not equal.
        /// </summary>
        /// <param name="left">The object to the left of the equality operator.</param>
        /// <param name="right">The object to the right of the equality operator.</param>
        /// <returns>true if the two items are not equal; otherwise false.</returns>
        public static bool operator !=(ModelPrivateSetGeneric<TFirst, TSecond> left, ModelPrivateSetGeneric<TFirst, TSecond> right) => !(left == right);

        /// <inheritdoc />
        [SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
        public bool Equals(ModelPrivateSetGeneric<TFirst, TSecond> other)
        {
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            if (ReferenceEquals(other, null))
            {
                return false;
            }

            var genericArgumentsUsedAsKeyInDictionary = new[] { typeof(TFirst), typeof(TSecond) };

            if (genericArgumentsUsedAsKeyInDictionary.Any(_ => (_ == typeof(DateTime)) || (_ == typeof(DateTime?))))
            {
                throw new NotSupportedException("This model contains one or more properties that are OR have within their generic argument tree or array element type a System Dictionary that is keyed on DateTime or DateTime?; IsEqualTo may do the wrong thing when comparing the keys of two such dictionaries (because it uses dictionary's embedded equality comparer, which is most likely the default comparer, which determines two DateTime objects to be equal if they have the same Ticks, regardless of whether they have the same Kind).");
            }

            var result = this.StringProperty.IsEqualTo(other.StringProperty, StringComparer.Ordinal)
                      && this.IntProperty.IsEqualTo(other.IntProperty)
                      && this.EnumProperty.IsEqualTo(other.EnumProperty)
                      && this.CustomClassProperty.IsEqualTo(other.CustomClassProperty)
                      && this.GenericArgumentProperty.IsEqualTo(other.GenericArgumentProperty)
                      && this.GenericArrayProperty.IsEqualTo(other.GenericArrayProperty)
                      && this.GenericNullableProperty.IsEqualTo(other.GenericNullableProperty)
                      && this.GenericCustomGenericClassProperty.IsEqualTo(other.GenericCustomGenericClassProperty)
                      && this.GenericReadOnlyCollectionProperty.IsEqualTo(other.GenericReadOnlyCollectionProperty)
                      && this.GenericReadOnlyListProperty.IsEqualTo(other.GenericReadOnlyListProperty)
                      && this.GenericReadOnlyDictionaryProperty1.IsEqualTo(other.GenericReadOnlyDictionaryProperty1)
                      && this.GenericReadOnlyDictionaryProperty2.IsEqualTo(other.GenericReadOnlyDictionaryProperty2)
                      && this.GenericPartiallyClosedReadOnlyDictionaryProperty1.IsEqualTo(other.GenericPartiallyClosedReadOnlyDictionaryProperty1)
                      && this.GenericPartiallyClosedReadOnlyDictionaryProperty2.IsEqualTo(other.GenericPartiallyClosedReadOnlyDictionaryProperty2);

            return result;
        }

        /// <inheritdoc />
        public override bool Equals(object obj) => this == (obj as ModelPrivateSetGeneric<TFirst, TSecond>);

        /// <summary>
        /// Determines whether an object of type <see cref="ModelPrivateSetGeneric{TFirst, TSecond}"/> is less than another object of that type.
        /// </summary>
        /// <param name="left">The object to the left of the less-than operator.</param>
        /// <param name="right">The object to the right of the less-than operator.</param>
        /// <returns>true if <paramref name="left"/> is less than <paramref name="right"/>; otherwise false.</returns>
        public static bool operator <(ModelPrivateSetGeneric<TFirst, TSecond> left, ModelPrivateSetGeneric<TFirst, TSecond> right)
        {
            if (ReferenceEquals(left, right))
            {
                return false;
            }

            if (ReferenceEquals(left, null))
            {
                return true;
            }

            if (ReferenceEquals(right, null))
            {
                return false;
            }

            if (left.GetType() != right.GetType())
            {
                throw new ArgumentException(Invariant($"Attempting to compare objects of different types.  The left operand is of type '{left.GetType().ToStringReadable()}' whereas the right operand is of type '{right.GetType().ToStringReadable()}'."));
            }

            var relativeSortOrder = left.CompareToForRelativeSortOrder(right);

            var result = relativeSortOrder == RelativeSortOrder.ThisInstancePrecedesTheOtherInstance;

            return result;
        }

        /// <summary>
        /// Determines whether an object of type <see cref="ModelPrivateSetGeneric{TFirst, TSecond}"/> is greater than another object of that type.
        /// </summary>
        /// <param name="left">The object to the left of the greater-than operator.</param>
        /// <param name="right">The object to the right of the greater-than operator.</param>
        /// <returns>true if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise false.</returns>
        public static bool operator >(ModelPrivateSetGeneric<TFirst, TSecond> left, ModelPrivateSetGeneric<TFirst, TSecond> right)
        {
            if (ReferenceEquals(left, right))
            {
                return false;
            }

            if (ReferenceEquals(left, null))
            {
                return false;
            }

            if (ReferenceEquals(right, null))
            {
                return true;
            }

            if (left.GetType() != right.GetType())
            {
                throw new ArgumentException(Invariant($"Attempting to compare objects of different types.  The left operand is of type '{left.GetType().ToStringReadable()}' whereas the right operand is of type '{right.GetType().ToStringReadable()}'."));
            }

            var relativeSortOrder = left.CompareToForRelativeSortOrder(right);

            var result = relativeSortOrder == RelativeSortOrder.ThisInstanceFollowsTheOtherInstance;

            return result;
        }

        /// <summary>
        /// Determines whether an object of type <see cref="ModelPrivateSetGeneric{TFirst, TSecond}"/> is less than or equal to another object of that type.
        /// </summary>
        /// <param name="left">The object to the left of the less-than-or-equal-to operator.</param>
        /// <param name="right">The object to the right of the less-than-or-equal-to operator.</param>
        /// <returns>true if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise false.</returns>
        public static bool operator <=(ModelPrivateSetGeneric<TFirst, TSecond> left, ModelPrivateSetGeneric<TFirst, TSecond> right) => !(left > right);

        /// <summary>
        /// Determines whether an object of type <see cref="ModelPrivateSetGeneric{TFirst, TSecond}"/> is greater than or equal to another object of that type.
        /// </summary>
        /// <param name="left">The object to the left of the greater-than-or-equal-to operator.</param>
        /// <param name="right">The object to the right of the greater-than-or-equal-to operator.</param>
        /// <returns>true if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise false.</returns>
        public static bool operator >=(ModelPrivateSetGeneric<TFirst, TSecond> left, ModelPrivateSetGeneric<TFirst, TSecond> right) => !(left < right);

        /// <inheritdoc />
        public int CompareTo(ModelPrivateSetGeneric<TFirst, TSecond> other)
        {
            if (ReferenceEquals(other, null))
            {
                return 1;
            }

            var relativeSortOrder = this.CompareToForRelativeSortOrder(other);

            switch(relativeSortOrder)
            {
                case RelativeSortOrder.ThisInstancePrecedesTheOtherInstance:
                    return -1;
                case RelativeSortOrder.ThisInstanceOccursInTheSamePositionAsTheOtherInstance:
                    return 0;
                case RelativeSortOrder.ThisInstanceFollowsTheOtherInstance:
                    return 1;
                default:
                    throw new NotSupportedException(Invariant($"This {nameof(RelativeSortOrder)} is not supported: {relativeSortOrder}."));
            }
        }

        /// <inheritdoc />
        public int CompareTo(object obj)
        {
            if (ReferenceEquals(obj, null))
            {
                return 1;
            }

            if (!(obj is ModelPrivateSetGeneric<TFirst, TSecond> other))
            {
                throw new ArgumentException(Invariant($"Attempting to compare objects of different types.  This object is of type 'ModelPrivateSetGeneric<TFirst, TSecond>' whereas the other object is of type '{obj.GetType().ToStringReadable()}'."));
            }

            var result = this.CompareTo(other);

            return result;
        }

        /// <inheritdoc />
        public override int GetHashCode() => HashCodeHelper.Initialize()
            .Hash(this.StringProperty)
            .Hash(this.IntProperty)
            .Hash(this.EnumProperty)
            .Hash(this.CustomClassProperty)
            .Hash(this.GenericArgumentProperty)
            .Hash(this.GenericArrayProperty)
            .Hash(this.GenericNullableProperty)
            .Hash(this.GenericCustomGenericClassProperty)
            .Hash(this.GenericReadOnlyCollectionProperty)
            .Hash(this.GenericReadOnlyListProperty)
            .Hash(this.GenericReadOnlyDictionaryProperty1)
            .Hash(this.GenericReadOnlyDictionaryProperty2)
            .Hash(this.GenericPartiallyClosedReadOnlyDictionaryProperty1)
            .Hash(this.GenericPartiallyClosedReadOnlyDictionaryProperty2)
            .Value;

        /// <inheritdoc />
        public object Clone() => this.DeepClone();

        /// <inheritdoc />
        public ModelPrivateSetGeneric<TFirst, TSecond> DeepClone()
        {
            var result = new ModelPrivateSetGeneric<TFirst, TSecond>(
                                 this.StringProperty?.DeepClone(),
                                 this.IntProperty.DeepClone(),
                                 this.EnumProperty.DeepClone(),
                                 this.CustomClassProperty?.DeepClone(),
                                 this.GenericArgumentProperty == null ? default : this.GenericArgumentProperty.DeepClone(),
                                 this.GenericArrayProperty?.DeepClone(),
                                 this.GenericNullableProperty?.DeepClone(),
                                 this.GenericCustomGenericClassProperty?.DeepClone(),
                                 this.GenericReadOnlyCollectionProperty?.DeepClone(),
                                 this.GenericReadOnlyListProperty?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty2?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty2?.DeepClone());

            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="StringProperty" />.
        /// </summary>
        /// <param name="stringProperty">The new <see cref="StringProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="ModelPrivateSetGeneric{TFirst, TSecond}" /> using the specified <paramref name="stringProperty" /> for <see cref="StringProperty" /> and a deep clone of every other property.</returns>
        [SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings")]
        [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
        [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
        [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public ModelPrivateSetGeneric<TFirst, TSecond> DeepCloneWithStringProperty(string stringProperty)
        {
            var result = new ModelPrivateSetGeneric<TFirst, TSecond>(
                                 stringProperty,
                                 this.IntProperty.DeepClone(),
                                 this.EnumProperty.DeepClone(),
                                 this.CustomClassProperty?.DeepClone(),
                                 this.GenericArgumentProperty == null ? default : this.GenericArgumentProperty.DeepClone(),
                                 this.GenericArrayProperty?.DeepClone(),
                                 this.GenericNullableProperty?.DeepClone(),
                                 this.GenericCustomGenericClassProperty?.DeepClone(),
                                 this.GenericReadOnlyCollectionProperty?.DeepClone(),
                                 this.GenericReadOnlyListProperty?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty2?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty2?.DeepClone());

            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="IntProperty" />.
        /// </summary>
        /// <param name="intProperty">The new <see cref="IntProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="ModelPrivateSetGeneric{TFirst, TSecond}" /> using the specified <paramref name="intProperty" /> for <see cref="IntProperty" /> and a deep clone of every other property.</returns>
        [SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings")]
        [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
        [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
        [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public ModelPrivateSetGeneric<TFirst, TSecond> DeepCloneWithIntProperty(int intProperty)
        {
            var result = new ModelPrivateSetGeneric<TFirst, TSecond>(
                                 this.StringProperty?.DeepClone(),
                                 intProperty,
                                 this.EnumProperty.DeepClone(),
                                 this.CustomClassProperty?.DeepClone(),
                                 this.GenericArgumentProperty == null ? default : this.GenericArgumentProperty.DeepClone(),
                                 this.GenericArrayProperty?.DeepClone(),
                                 this.GenericNullableProperty?.DeepClone(),
                                 this.GenericCustomGenericClassProperty?.DeepClone(),
                                 this.GenericReadOnlyCollectionProperty?.DeepClone(),
                                 this.GenericReadOnlyListProperty?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty2?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty2?.DeepClone());

            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="EnumProperty" />.
        /// </summary>
        /// <param name="enumProperty">The new <see cref="EnumProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="ModelPrivateSetGeneric{TFirst, TSecond}" /> using the specified <paramref name="enumProperty" /> for <see cref="EnumProperty" /> and a deep clone of every other property.</returns>
        [SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings")]
        [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
        [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
        [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public ModelPrivateSetGeneric<TFirst, TSecond> DeepCloneWithEnumProperty(CustomEnum enumProperty)
        {
            var result = new ModelPrivateSetGeneric<TFirst, TSecond>(
                                 this.StringProperty?.DeepClone(),
                                 this.IntProperty.DeepClone(),
                                 enumProperty,
                                 this.CustomClassProperty?.DeepClone(),
                                 this.GenericArgumentProperty == null ? default : this.GenericArgumentProperty.DeepClone(),
                                 this.GenericArrayProperty?.DeepClone(),
                                 this.GenericNullableProperty?.DeepClone(),
                                 this.GenericCustomGenericClassProperty?.DeepClone(),
                                 this.GenericReadOnlyCollectionProperty?.DeepClone(),
                                 this.GenericReadOnlyListProperty?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty2?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty2?.DeepClone());

            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="CustomClassProperty" />.
        /// </summary>
        /// <param name="customClassProperty">The new <see cref="CustomClassProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="ModelPrivateSetGeneric{TFirst, TSecond}" /> using the specified <paramref name="customClassProperty" /> for <see cref="CustomClassProperty" /> and a deep clone of every other property.</returns>
        [SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings")]
        [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
        [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
        [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public ModelPrivateSetGeneric<TFirst, TSecond> DeepCloneWithCustomClassProperty(CustomClass customClassProperty)
        {
            var result = new ModelPrivateSetGeneric<TFirst, TSecond>(
                                 this.StringProperty?.DeepClone(),
                                 this.IntProperty.DeepClone(),
                                 this.EnumProperty.DeepClone(),
                                 customClassProperty,
                                 this.GenericArgumentProperty == null ? default : this.GenericArgumentProperty.DeepClone(),
                                 this.GenericArrayProperty?.DeepClone(),
                                 this.GenericNullableProperty?.DeepClone(),
                                 this.GenericCustomGenericClassProperty?.DeepClone(),
                                 this.GenericReadOnlyCollectionProperty?.DeepClone(),
                                 this.GenericReadOnlyListProperty?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty2?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty2?.DeepClone());

            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="GenericArgumentProperty" />.
        /// </summary>
        /// <param name="genericArgumentProperty">The new <see cref="GenericArgumentProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="ModelPrivateSetGeneric{TFirst, TSecond}" /> using the specified <paramref name="genericArgumentProperty" /> for <see cref="GenericArgumentProperty" /> and a deep clone of every other property.</returns>
        [SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings")]
        [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
        [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
        [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public ModelPrivateSetGeneric<TFirst, TSecond> DeepCloneWithGenericArgumentProperty(TFirst genericArgumentProperty)
        {
            var result = new ModelPrivateSetGeneric<TFirst, TSecond>(
                                 this.StringProperty?.DeepClone(),
                                 this.IntProperty.DeepClone(),
                                 this.EnumProperty.DeepClone(),
                                 this.CustomClassProperty?.DeepClone(),
                                 genericArgumentProperty,
                                 this.GenericArrayProperty?.DeepClone(),
                                 this.GenericNullableProperty?.DeepClone(),
                                 this.GenericCustomGenericClassProperty?.DeepClone(),
                                 this.GenericReadOnlyCollectionProperty?.DeepClone(),
                                 this.GenericReadOnlyListProperty?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty2?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty2?.DeepClone());

            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="GenericArrayProperty" />.
        /// </summary>
        /// <param name="genericArrayProperty">The new <see cref="GenericArrayProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="ModelPrivateSetGeneric{TFirst, TSecond}" /> using the specified <paramref name="genericArrayProperty" /> for <see cref="GenericArrayProperty" /> and a deep clone of every other property.</returns>
        [SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings")]
        [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
        [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
        [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public ModelPrivateSetGeneric<TFirst, TSecond> DeepCloneWithGenericArrayProperty(TFirst[] genericArrayProperty)
        {
            var result = new ModelPrivateSetGeneric<TFirst, TSecond>(
                                 this.StringProperty?.DeepClone(),
                                 this.IntProperty.DeepClone(),
                                 this.EnumProperty.DeepClone(),
                                 this.CustomClassProperty?.DeepClone(),
                                 this.GenericArgumentProperty == null ? default : this.GenericArgumentProperty.DeepClone(),
                                 genericArrayProperty,
                                 this.GenericNullableProperty?.DeepClone(),
                                 this.GenericCustomGenericClassProperty?.DeepClone(),
                                 this.GenericReadOnlyCollectionProperty?.DeepClone(),
                                 this.GenericReadOnlyListProperty?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty2?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty2?.DeepClone());

            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="GenericNullableProperty" />.
        /// </summary>
        /// <param name="genericNullableProperty">The new <see cref="GenericNullableProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="ModelPrivateSetGeneric{TFirst, TSecond}" /> using the specified <paramref name="genericNullableProperty" /> for <see cref="GenericNullableProperty" /> and a deep clone of every other property.</returns>
        [SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings")]
        [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
        [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
        [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public ModelPrivateSetGeneric<TFirst, TSecond> DeepCloneWithGenericNullableProperty(Nullable<TSecond> genericNullableProperty)
        {
            var result = new ModelPrivateSetGeneric<TFirst, TSecond>(
                                 this.StringProperty?.DeepClone(),
                                 this.IntProperty.DeepClone(),
                                 this.EnumProperty.DeepClone(),
                                 this.CustomClassProperty?.DeepClone(),
                                 this.GenericArgumentProperty == null ? default : this.GenericArgumentProperty.DeepClone(),
                                 this.GenericArrayProperty?.DeepClone(),
                                 genericNullableProperty,
                                 this.GenericCustomGenericClassProperty?.DeepClone(),
                                 this.GenericReadOnlyCollectionProperty?.DeepClone(),
                                 this.GenericReadOnlyListProperty?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty2?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty2?.DeepClone());

            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="GenericCustomGenericClassProperty" />.
        /// </summary>
        /// <param name="genericCustomGenericClassProperty">The new <see cref="GenericCustomGenericClassProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="ModelPrivateSetGeneric{TFirst, TSecond}" /> using the specified <paramref name="genericCustomGenericClassProperty" /> for <see cref="GenericCustomGenericClassProperty" /> and a deep clone of every other property.</returns>
        [SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings")]
        [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
        [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
        [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public ModelPrivateSetGeneric<TFirst, TSecond> DeepCloneWithGenericCustomGenericClassProperty(CustomGenericClass<TSecond> genericCustomGenericClassProperty)
        {
            var result = new ModelPrivateSetGeneric<TFirst, TSecond>(
                                 this.StringProperty?.DeepClone(),
                                 this.IntProperty.DeepClone(),
                                 this.EnumProperty.DeepClone(),
                                 this.CustomClassProperty?.DeepClone(),
                                 this.GenericArgumentProperty == null ? default : this.GenericArgumentProperty.DeepClone(),
                                 this.GenericArrayProperty?.DeepClone(),
                                 this.GenericNullableProperty?.DeepClone(),
                                 genericCustomGenericClassProperty,
                                 this.GenericReadOnlyCollectionProperty?.DeepClone(),
                                 this.GenericReadOnlyListProperty?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty2?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty2?.DeepClone());

            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="GenericReadOnlyCollectionProperty" />.
        /// </summary>
        /// <param name="genericReadOnlyCollectionProperty">The new <see cref="GenericReadOnlyCollectionProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="ModelPrivateSetGeneric{TFirst, TSecond}" /> using the specified <paramref name="genericReadOnlyCollectionProperty" /> for <see cref="GenericReadOnlyCollectionProperty" /> and a deep clone of every other property.</returns>
        [SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings")]
        [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
        [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
        [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public ModelPrivateSetGeneric<TFirst, TSecond> DeepCloneWithGenericReadOnlyCollectionProperty(IReadOnlyCollection<TFirst> genericReadOnlyCollectionProperty)
        {
            var result = new ModelPrivateSetGeneric<TFirst, TSecond>(
                                 this.StringProperty?.DeepClone(),
                                 this.IntProperty.DeepClone(),
                                 this.EnumProperty.DeepClone(),
                                 this.CustomClassProperty?.DeepClone(),
                                 this.GenericArgumentProperty == null ? default : this.GenericArgumentProperty.DeepClone(),
                                 this.GenericArrayProperty?.DeepClone(),
                                 this.GenericNullableProperty?.DeepClone(),
                                 this.GenericCustomGenericClassProperty?.DeepClone(),
                                 genericReadOnlyCollectionProperty,
                                 this.GenericReadOnlyListProperty?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty2?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty2?.DeepClone());

            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="GenericReadOnlyListProperty" />.
        /// </summary>
        /// <param name="genericReadOnlyListProperty">The new <see cref="GenericReadOnlyListProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="ModelPrivateSetGeneric{TFirst, TSecond}" /> using the specified <paramref name="genericReadOnlyListProperty" /> for <see cref="GenericReadOnlyListProperty" /> and a deep clone of every other property.</returns>
        [SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings")]
        [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
        [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
        [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public ModelPrivateSetGeneric<TFirst, TSecond> DeepCloneWithGenericReadOnlyListProperty(IReadOnlyList<TFirst> genericReadOnlyListProperty)
        {
            var result = new ModelPrivateSetGeneric<TFirst, TSecond>(
                                 this.StringProperty?.DeepClone(),
                                 this.IntProperty.DeepClone(),
                                 this.EnumProperty.DeepClone(),
                                 this.CustomClassProperty?.DeepClone(),
                                 this.GenericArgumentProperty == null ? default : this.GenericArgumentProperty.DeepClone(),
                                 this.GenericArrayProperty?.DeepClone(),
                                 this.GenericNullableProperty?.DeepClone(),
                                 this.GenericCustomGenericClassProperty?.DeepClone(),
                                 this.GenericReadOnlyCollectionProperty?.DeepClone(),
                                 genericReadOnlyListProperty,
                                 this.GenericReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty2?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty2?.DeepClone());

            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="GenericReadOnlyDictionaryProperty1" />.
        /// </summary>
        /// <param name="genericReadOnlyDictionaryProperty1">The new <see cref="GenericReadOnlyDictionaryProperty1" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="ModelPrivateSetGeneric{TFirst, TSecond}" /> using the specified <paramref name="genericReadOnlyDictionaryProperty1" /> for <see cref="GenericReadOnlyDictionaryProperty1" /> and a deep clone of every other property.</returns>
        [SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings")]
        [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
        [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
        [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public ModelPrivateSetGeneric<TFirst, TSecond> DeepCloneWithGenericReadOnlyDictionaryProperty1(IReadOnlyDictionary<TFirst, TSecond> genericReadOnlyDictionaryProperty1)
        {
            var result = new ModelPrivateSetGeneric<TFirst, TSecond>(
                                 this.StringProperty?.DeepClone(),
                                 this.IntProperty.DeepClone(),
                                 this.EnumProperty.DeepClone(),
                                 this.CustomClassProperty?.DeepClone(),
                                 this.GenericArgumentProperty == null ? default : this.GenericArgumentProperty.DeepClone(),
                                 this.GenericArrayProperty?.DeepClone(),
                                 this.GenericNullableProperty?.DeepClone(),
                                 this.GenericCustomGenericClassProperty?.DeepClone(),
                                 this.GenericReadOnlyCollectionProperty?.DeepClone(),
                                 this.GenericReadOnlyListProperty?.DeepClone(),
                                 genericReadOnlyDictionaryProperty1,
                                 this.GenericReadOnlyDictionaryProperty2?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty2?.DeepClone());

            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="GenericReadOnlyDictionaryProperty2" />.
        /// </summary>
        /// <param name="genericReadOnlyDictionaryProperty2">The new <see cref="GenericReadOnlyDictionaryProperty2" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="ModelPrivateSetGeneric{TFirst, TSecond}" /> using the specified <paramref name="genericReadOnlyDictionaryProperty2" /> for <see cref="GenericReadOnlyDictionaryProperty2" /> and a deep clone of every other property.</returns>
        [SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings")]
        [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
        [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
        [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public ModelPrivateSetGeneric<TFirst, TSecond> DeepCloneWithGenericReadOnlyDictionaryProperty2(IReadOnlyDictionary<TSecond, TFirst> genericReadOnlyDictionaryProperty2)
        {
            var result = new ModelPrivateSetGeneric<TFirst, TSecond>(
                                 this.StringProperty?.DeepClone(),
                                 this.IntProperty.DeepClone(),
                                 this.EnumProperty.DeepClone(),
                                 this.CustomClassProperty?.DeepClone(),
                                 this.GenericArgumentProperty == null ? default : this.GenericArgumentProperty.DeepClone(),
                                 this.GenericArrayProperty?.DeepClone(),
                                 this.GenericNullableProperty?.DeepClone(),
                                 this.GenericCustomGenericClassProperty?.DeepClone(),
                                 this.GenericReadOnlyCollectionProperty?.DeepClone(),
                                 this.GenericReadOnlyListProperty?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty1?.DeepClone(),
                                 genericReadOnlyDictionaryProperty2,
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty2?.DeepClone());

            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="GenericPartiallyClosedReadOnlyDictionaryProperty1" />.
        /// </summary>
        /// <param name="genericPartiallyClosedReadOnlyDictionaryProperty1">The new <see cref="GenericPartiallyClosedReadOnlyDictionaryProperty1" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="ModelPrivateSetGeneric{TFirst, TSecond}" /> using the specified <paramref name="genericPartiallyClosedReadOnlyDictionaryProperty1" /> for <see cref="GenericPartiallyClosedReadOnlyDictionaryProperty1" /> and a deep clone of every other property.</returns>
        [SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings")]
        [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
        [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
        [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public ModelPrivateSetGeneric<TFirst, TSecond> DeepCloneWithGenericPartiallyClosedReadOnlyDictionaryProperty1(IReadOnlyDictionary<string, TSecond> genericPartiallyClosedReadOnlyDictionaryProperty1)
        {
            var result = new ModelPrivateSetGeneric<TFirst, TSecond>(
                                 this.StringProperty?.DeepClone(),
                                 this.IntProperty.DeepClone(),
                                 this.EnumProperty.DeepClone(),
                                 this.CustomClassProperty?.DeepClone(),
                                 this.GenericArgumentProperty == null ? default : this.GenericArgumentProperty.DeepClone(),
                                 this.GenericArrayProperty?.DeepClone(),
                                 this.GenericNullableProperty?.DeepClone(),
                                 this.GenericCustomGenericClassProperty?.DeepClone(),
                                 this.GenericReadOnlyCollectionProperty?.DeepClone(),
                                 this.GenericReadOnlyListProperty?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty2?.DeepClone(),
                                 genericPartiallyClosedReadOnlyDictionaryProperty1,
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty2?.DeepClone());

            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="GenericPartiallyClosedReadOnlyDictionaryProperty2" />.
        /// </summary>
        /// <param name="genericPartiallyClosedReadOnlyDictionaryProperty2">The new <see cref="GenericPartiallyClosedReadOnlyDictionaryProperty2" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="ModelPrivateSetGeneric{TFirst, TSecond}" /> using the specified <paramref name="genericPartiallyClosedReadOnlyDictionaryProperty2" /> for <see cref="GenericPartiallyClosedReadOnlyDictionaryProperty2" /> and a deep clone of every other property.</returns>
        [SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings")]
        [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
        [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
        [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
        [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
        [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public ModelPrivateSetGeneric<TFirst, TSecond> DeepCloneWithGenericPartiallyClosedReadOnlyDictionaryProperty2(IReadOnlyDictionary<TFirst, string> genericPartiallyClosedReadOnlyDictionaryProperty2)
        {
            var result = new ModelPrivateSetGeneric<TFirst, TSecond>(
                                 this.StringProperty?.DeepClone(),
                                 this.IntProperty.DeepClone(),
                                 this.EnumProperty.DeepClone(),
                                 this.CustomClassProperty?.DeepClone(),
                                 this.GenericArgumentProperty == null ? default : this.GenericArgumentProperty.DeepClone(),
                                 this.GenericArrayProperty?.DeepClone(),
                                 this.GenericNullableProperty?.DeepClone(),
                                 this.GenericCustomGenericClassProperty?.DeepClone(),
                                 this.GenericReadOnlyCollectionProperty?.DeepClone(),
                                 this.GenericReadOnlyListProperty?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty1?.DeepClone(),
                                 this.GenericReadOnlyDictionaryProperty2?.DeepClone(),
                                 this.GenericPartiallyClosedReadOnlyDictionaryProperty1?.DeepClone(),
                                 genericPartiallyClosedReadOnlyDictionaryProperty2);

            return result;
        }

        /// <inheritdoc />
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override string ToString()
        {
            var result = Invariant($"OBeautifulCode.CodeGen.ModelObject.Test.{this.GetType().ToStringReadable()}: StringProperty = {this.StringProperty?.ToString(CultureInfo.InvariantCulture) ?? "<null>"}, IntProperty = {this.IntProperty.ToString(CultureInfo.InvariantCulture) ?? "<null>"}, EnumProperty = {this.EnumProperty.ToString() ?? "<null>"}, CustomClassProperty = {this.CustomClassProperty?.ToString() ?? "<null>"}, GenericArgumentProperty = {this.GenericArgumentProperty?.ToString() ?? "<null>"}, GenericArrayProperty = {this.GenericArrayProperty?.ToString() ?? "<null>"}, GenericNullableProperty = {this.GenericNullableProperty?.ToString() ?? "<null>"}, GenericCustomGenericClassProperty = {this.GenericCustomGenericClassProperty?.ToString() ?? "<null>"}, GenericReadOnlyCollectionProperty = {this.GenericReadOnlyCollectionProperty?.ToString() ?? "<null>"}, GenericReadOnlyListProperty = {this.GenericReadOnlyListProperty?.ToString() ?? "<null>"}, GenericReadOnlyDictionaryProperty1 = {this.GenericReadOnlyDictionaryProperty1?.ToString() ?? "<null>"}, GenericReadOnlyDictionaryProperty2 = {this.GenericReadOnlyDictionaryProperty2?.ToString() ?? "<null>"}, GenericPartiallyClosedReadOnlyDictionaryProperty1 = {this.GenericPartiallyClosedReadOnlyDictionaryProperty1?.ToString() ?? "<null>"}, GenericPartiallyClosedReadOnlyDictionaryProperty2 = {this.GenericPartiallyClosedReadOnlyDictionaryProperty2?.ToString() ?? "<null>"}.");

            return result;
        }

        /// <inheritdoc />
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public IReadOnlyList<ValidationFailure> GetValidationFailures(
            ValidationOptions options = null,
            PropertyPathTracker propertyPathTracker = null)
        {
            options = options ?? new ValidationOptions();
            propertyPathTracker = propertyPathTracker ?? new PropertyPathTracker();

            bool stopOnFirstObjectWithFailures;
            switch (options.ValidateUntil)
            {
                case ValidateUntil.FullyTraversed:
                    stopOnFirstObjectWithFailures = false;
                    break;
                case ValidateUntil.FirstInvalidObject:
                    stopOnFirstObjectWithFailures = true;
                    break;
                default:
                    throw new NotSupportedException(Invariant($"This {nameof(ValidateUntil)} is not supported: {options.ValidateUntil}."));
            }

            bool validateProperties;
            switch (options.ValidationScope)
            {
                case ValidationScope.SelfAndProperties:
                    validateProperties = true;
                    break;
                case ValidationScope.SelfOnly:
                    validateProperties = false;
                    break;
                default:
                    throw new NotSupportedException(Invariant($"This {nameof(ValidationScope)} is not supported: {options.ValidationScope}."));
            }

            var result = new List<ValidationFailure>();

            void ValidateProperties()
            {
                IReadOnlyList<ValidationFailure> localValidationFailures;

                localValidationFailures = ValidatableExtensions.GetValidationFailures(this.StringProperty, options, propertyPathTracker, nameof(this.StringProperty));
                result.AddRange(localValidationFailures);
                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return;
                }

                localValidationFailures = ValidatableExtensions.GetValidationFailures(this.IntProperty, options, propertyPathTracker, nameof(this.IntProperty));
                result.AddRange(localValidationFailures);
                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return;
                }

                localValidationFailures = ValidatableExtensions.GetValidationFailures(this.EnumProperty, options, propertyPathTracker, nameof(this.EnumProperty));
                result.AddRange(localValidationFailures);
                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return;
                }

                localValidationFailures = ValidatableExtensions.GetValidationFailures(this.CustomClassProperty, options, propertyPathTracker, nameof(this.CustomClassProperty));
                result.AddRange(localValidationFailures);
                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return;
                }

                localValidationFailures = ValidatableExtensions.GetValidationFailures(this.GenericArgumentProperty, options, propertyPathTracker, nameof(this.GenericArgumentProperty));
                result.AddRange(localValidationFailures);
                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return;
                }

                localValidationFailures = ValidatableExtensions.GetValidationFailures(this.GenericArrayProperty, options, propertyPathTracker, nameof(this.GenericArrayProperty));
                result.AddRange(localValidationFailures);
                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return;
                }

                localValidationFailures = ValidatableExtensions.GetValidationFailures(this.GenericNullableProperty, options, propertyPathTracker, nameof(this.GenericNullableProperty));
                result.AddRange(localValidationFailures);
                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return;
                }

                localValidationFailures = ValidatableExtensions.GetValidationFailures(this.GenericCustomGenericClassProperty, options, propertyPathTracker, nameof(this.GenericCustomGenericClassProperty));
                result.AddRange(localValidationFailures);
                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return;
                }

                localValidationFailures = ValidatableExtensions.GetValidationFailures(this.GenericReadOnlyCollectionProperty, options, propertyPathTracker, nameof(this.GenericReadOnlyCollectionProperty));
                result.AddRange(localValidationFailures);
                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return;
                }

                localValidationFailures = ValidatableExtensions.GetValidationFailures(this.GenericReadOnlyListProperty, options, propertyPathTracker, nameof(this.GenericReadOnlyListProperty));
                result.AddRange(localValidationFailures);
                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return;
                }

                localValidationFailures = ValidatableExtensions.GetValidationFailures(this.GenericReadOnlyDictionaryProperty1, options, propertyPathTracker, nameof(this.GenericReadOnlyDictionaryProperty1));
                result.AddRange(localValidationFailures);
                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return;
                }

                localValidationFailures = ValidatableExtensions.GetValidationFailures(this.GenericReadOnlyDictionaryProperty2, options, propertyPathTracker, nameof(this.GenericReadOnlyDictionaryProperty2));
                result.AddRange(localValidationFailures);
                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return;
                }

                localValidationFailures = ValidatableExtensions.GetValidationFailures(this.GenericPartiallyClosedReadOnlyDictionaryProperty1, options, propertyPathTracker, nameof(this.GenericPartiallyClosedReadOnlyDictionaryProperty1));
                result.AddRange(localValidationFailures);
                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return;
                }

                localValidationFailures = ValidatableExtensions.GetValidationFailures(this.GenericPartiallyClosedReadOnlyDictionaryProperty2, options, propertyPathTracker, nameof(this.GenericPartiallyClosedReadOnlyDictionaryProperty2));
                result.AddRange(localValidationFailures);
                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return;
                }
            }

            void ValidateSelf()
            {
                var segmentSeparator = propertyPathTracker.HasSegments ? propertyPathTracker.SegmentSeparator : string.Empty;

                var selfValidationFailures = (this.GetSelfValidationFailures() ?? new SelfValidationFailure[0])
                    .Where(_ => _ != null)
                    .Select(_ =>
                    {
                        var propertyNames = _.PropertyNames.Count > 1
                            ? Invariant($"({string.Join("|", _.PropertyNames)})")
                            : _.PropertyNames.Single();

                        return new ValidationFailure(
                            this.GetType().ToStringReadable(),
                            Invariant($"{propertyPathTracker.FullPath}{segmentSeparator}{propertyNames}"),
                            _.Message);
                    })
                    .ToList();

                result.AddRange(selfValidationFailures);
            }

            if (options.ValidationOrder == ValidationOrder.PropertiesThenSelf)
            {
                if (validateProperties)
                {
                    ValidateProperties();
                }

                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return result;
                }

                ValidateSelf();
            }
            else if (options.ValidationOrder == ValidationOrder.SelfThenProperties)
            {
                ValidateSelf();

                if (stopOnFirstObjectWithFailures && result.Any())
                {
                    return result;
                }

                if (validateProperties)
                {
                    ValidateProperties();
                }
            }
            else
            {
                throw new NotSupportedException(Invariant($"This {nameof(ValidationOrder)} is not supported: {options.ValidationOrder}."));
            }

            return result;
        }

        /// <inheritdoc />
        public IReadOnlyList<SelfValidationFailure> GetSelfValidationFailures()
        {
            var result = new SelfValidationFailure[0];

            return result;
        }
    }
}