// --------------------------------------------------------------------------------------------------------------------
// <auto-generated>
//   Generated using OBeautifulCode.CodeGen.ModelObject (1.0.0.0)
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.CodeGen.ModelObject.Test
{
    using System;
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.Linq;

    using OBeautifulCode.Equality.Recipes;
    using OBeautifulCode.Type;

    using static System.FormattableString;

    [ExcludeFromCodeCoverage]
    [GeneratedCode("OBeautifulCode.CodeGen.ModelObject", "1.0.0.0")]
    public partial class MyModelPublicSetters : IModel<MyModelPublicSetters>
    {
        /// <summary>
        /// Determines whether two objects of type <see cref="MyModelPublicSetters"/> are equal.
        /// </summary>
        /// <param name="left">The object to the left of the equality operator.</param>
        /// <param name="right">The object to the right of the equality operator.</param>
        /// <returns>true if the two items are equal; otherwise false.</returns>
        public static bool operator ==(MyModelPublicSetters left, MyModelPublicSetters right)
        {
            if (ReferenceEquals(left, right))
            {
                return true;
            }

            if (ReferenceEquals(left, null) || ReferenceEquals(right, null))
            {
                return false;
            }

            var result = left.IntProperty.Equals(right.IntProperty)
                      && left.StringProperty.Equals(right.StringProperty, StringComparison.Ordinal)
                      && left.ModelEquatableClassProperty.Equals(right.ModelEquatableClassProperty)
                      && left.ReadOnlyListOfIntProperty.IsEqualTo(right.ReadOnlyListOfIntProperty)
                      && left.ReadOnlyListOfStringProperty.IsEqualTo(right.ReadOnlyListOfStringProperty)
                      && left.ReadOnlyListOfModelEquatableClassProperty.IsEqualTo(right.ReadOnlyListOfModelEquatableClassProperty);

            return result;
        }

        /// <summary>
        /// Determines whether two objects of type <see cref="MyModelPublicSetters"/> are not equal.
        /// </summary>
        /// <param name="left">The object to the left of the equality operator.</param>
        /// <param name="right">The object to the right of the equality operator.</param>
        /// <returns>true if the two items not equal; otherwise false.</returns>
        public static bool operator !=(MyModelPublicSetters left, MyModelPublicSetters right) => !(left == right);

        /// <inheritdoc />
        public bool Equals(MyModelPublicSetters other) => this == other;

        /// <inheritdoc />
        public override bool Equals(object obj) => this == (obj as MyModelPublicSetters);
    
        /// <inheritdoc />
        public override int GetHashCode() => HashCodeHelper.Initialize()
            .Hash(this.IntProperty)
            .Hash(this.StringProperty)
            .Hash(this.ModelEquatableClassProperty)
            .Hash(this.ReadOnlyListOfIntProperty)
            .Hash(this.ReadOnlyListOfStringProperty)
            .Hash(this.ReadOnlyListOfModelEquatableClassProperty)
            .Value;
    
        /// <inheritdoc />
        public object Clone() => this.DeepClone();

        /// <inheritdoc />
        public MyModelPublicSetters DeepClone()
        {
            var result = new MyModelPublicSetters
                             {
                                 IntProperty                               = this.IntProperty,
                                 StringProperty                            = this.StringProperty?.Clone().ToString(),
                                 ModelEquatableClassProperty               = this.ModelEquatableClassProperty?.DeepClone(),
                                 ReadOnlyListOfIntProperty                 = this.ReadOnlyListOfIntProperty?.Select(i => i).ToList(),
                                 ReadOnlyListOfStringProperty              = this.ReadOnlyListOfStringProperty?.Select(i => i?.Clone().ToString()).ToList(),
                                 ReadOnlyListOfModelEquatableClassProperty = this.ReadOnlyListOfModelEquatableClassProperty?.Select(i => i?.DeepClone()).ToList()
                             };

            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="IntProperty" />.
        /// </summary>
        /// <param name="intProperty">The new <see cref="IntProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="MyModelPublicSetters" /> using the specified <paramref name="intProperty" /> for <see cref="IntProperty" /> and a deep clone of every other property.</returns>
        public MyModelPublicSetters DeepCloneWithIntProperty(int intProperty)
        {
            var result = new MyModelPublicSetters
                             {
                                 IntProperty                               = intProperty,
                                 StringProperty                            = this.StringProperty?.Clone().ToString(),
                                 ModelEquatableClassProperty               = this.ModelEquatableClassProperty?.DeepClone(),
                                 ReadOnlyListOfIntProperty                 = this.ReadOnlyListOfIntProperty?.Select(i => i).ToList(),
                                 ReadOnlyListOfStringProperty              = this.ReadOnlyListOfStringProperty?.Select(i => i?.Clone().ToString()).ToList(),
                                 ReadOnlyListOfModelEquatableClassProperty = this.ReadOnlyListOfModelEquatableClassProperty?.Select(i => i?.DeepClone()).ToList()
                             };
            
            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="StringProperty" />.
        /// </summary>
        /// <param name="stringProperty">The new <see cref="StringProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="MyModelPublicSetters" /> using the specified <paramref name="stringProperty" /> for <see cref="StringProperty" /> and a deep clone of every other property.</returns>
        public MyModelPublicSetters DeepCloneWithStringProperty(string stringProperty)
        {
            var result = new MyModelPublicSetters
                             {
                                 IntProperty                               = this.IntProperty,
                                 StringProperty                            = stringProperty,
                                 ModelEquatableClassProperty               = this.ModelEquatableClassProperty?.DeepClone(),
                                 ReadOnlyListOfIntProperty                 = this.ReadOnlyListOfIntProperty?.Select(i => i).ToList(),
                                 ReadOnlyListOfStringProperty              = this.ReadOnlyListOfStringProperty?.Select(i => i?.Clone().ToString()).ToList(),
                                 ReadOnlyListOfModelEquatableClassProperty = this.ReadOnlyListOfModelEquatableClassProperty?.Select(i => i?.DeepClone()).ToList()
                             };
            
            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="ModelEquatableClassProperty" />.
        /// </summary>
        /// <param name="modelEquatableClassProperty">The new <see cref="ModelEquatableClassProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="MyModelPublicSetters" /> using the specified <paramref name="modelEquatableClassProperty" /> for <see cref="ModelEquatableClassProperty" /> and a deep clone of every other property.</returns>
        public MyModelPublicSetters DeepCloneWithModelEquatableClassProperty(ModelEquatableClass modelEquatableClassProperty)
        {
            var result = new MyModelPublicSetters
                             {
                                 IntProperty                               = this.IntProperty,
                                 StringProperty                            = this.StringProperty?.Clone().ToString(),
                                 ModelEquatableClassProperty               = modelEquatableClassProperty,
                                 ReadOnlyListOfIntProperty                 = this.ReadOnlyListOfIntProperty?.Select(i => i).ToList(),
                                 ReadOnlyListOfStringProperty              = this.ReadOnlyListOfStringProperty?.Select(i => i?.Clone().ToString()).ToList(),
                                 ReadOnlyListOfModelEquatableClassProperty = this.ReadOnlyListOfModelEquatableClassProperty?.Select(i => i?.DeepClone()).ToList()
                             };
            
            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="ReadOnlyListOfIntProperty" />.
        /// </summary>
        /// <param name="readOnlyListOfIntProperty">The new <see cref="ReadOnlyListOfIntProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="MyModelPublicSetters" /> using the specified <paramref name="readOnlyListOfIntProperty" /> for <see cref="ReadOnlyListOfIntProperty" /> and a deep clone of every other property.</returns>
        public MyModelPublicSetters DeepCloneWithReadOnlyListOfIntProperty(IReadOnlyList<int> readOnlyListOfIntProperty)
        {
            var result = new MyModelPublicSetters
                             {
                                 IntProperty                               = this.IntProperty,
                                 StringProperty                            = this.StringProperty?.Clone().ToString(),
                                 ModelEquatableClassProperty               = this.ModelEquatableClassProperty?.DeepClone(),
                                 ReadOnlyListOfIntProperty                 = readOnlyListOfIntProperty,
                                 ReadOnlyListOfStringProperty              = this.ReadOnlyListOfStringProperty?.Select(i => i?.Clone().ToString()).ToList(),
                                 ReadOnlyListOfModelEquatableClassProperty = this.ReadOnlyListOfModelEquatableClassProperty?.Select(i => i?.DeepClone()).ToList()
                             };
            
            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="ReadOnlyListOfStringProperty" />.
        /// </summary>
        /// <param name="readOnlyListOfStringProperty">The new <see cref="ReadOnlyListOfStringProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="MyModelPublicSetters" /> using the specified <paramref name="readOnlyListOfStringProperty" /> for <see cref="ReadOnlyListOfStringProperty" /> and a deep clone of every other property.</returns>
        public MyModelPublicSetters DeepCloneWithReadOnlyListOfStringProperty(IReadOnlyList<string> readOnlyListOfStringProperty)
        {
            var result = new MyModelPublicSetters
                             {
                                 IntProperty                               = this.IntProperty,
                                 StringProperty                            = this.StringProperty?.Clone().ToString(),
                                 ModelEquatableClassProperty               = this.ModelEquatableClassProperty?.DeepClone(),
                                 ReadOnlyListOfIntProperty                 = this.ReadOnlyListOfIntProperty?.Select(i => i).ToList(),
                                 ReadOnlyListOfStringProperty              = readOnlyListOfStringProperty,
                                 ReadOnlyListOfModelEquatableClassProperty = this.ReadOnlyListOfModelEquatableClassProperty?.Select(i => i?.DeepClone()).ToList()
                             };
            
            return result;
        }

        /// <summary>
        /// Deep clones this object with a new <see cref="ReadOnlyListOfModelEquatableClassProperty" />.
        /// </summary>
        /// <param name="readOnlyListOfModelEquatableClassProperty">The new <see cref="ReadOnlyListOfModelEquatableClassProperty" />.  This object will NOT be deep cloned; it is used as-is.</param>
        /// <returns>New <see cref="MyModelPublicSetters" /> using the specified <paramref name="readOnlyListOfModelEquatableClassProperty" /> for <see cref="ReadOnlyListOfModelEquatableClassProperty" /> and a deep clone of every other property.</returns>
        public MyModelPublicSetters DeepCloneWithReadOnlyListOfModelEquatableClassProperty(IReadOnlyList<ModelEquatableClass> readOnlyListOfModelEquatableClassProperty)
        {
            var result = new MyModelPublicSetters
                             {
                                 IntProperty                               = this.IntProperty,
                                 StringProperty                            = this.StringProperty?.Clone().ToString(),
                                 ModelEquatableClassProperty               = this.ModelEquatableClassProperty?.DeepClone(),
                                 ReadOnlyListOfIntProperty                 = this.ReadOnlyListOfIntProperty?.Select(i => i).ToList(),
                                 ReadOnlyListOfStringProperty              = this.ReadOnlyListOfStringProperty?.Select(i => i?.Clone().ToString()).ToList(),
                                 ReadOnlyListOfModelEquatableClassProperty = readOnlyListOfModelEquatableClassProperty
                             };
            
            return result;
        }
    
        /// <inheritdoc />
        public override string ToString()
        {
            var result = Invariant($"{nameof(OBeautifulCode.CodeGen.ModelObject.Test)}.{nameof(MyModelPublicSetters)}: IntProperty = {this.IntProperty.ToString(CultureInfo.InvariantCulture) ?? "<null>"}, StringProperty = {this.StringProperty?.ToString() ?? "<null>"}, ModelEquatableClassProperty = {this.ModelEquatableClassProperty?.ToString() ?? "<null>"}, ReadOnlyListOfIntProperty = {this.ReadOnlyListOfIntProperty?.ToString() ?? "<null>"}, ReadOnlyListOfStringProperty = {this.ReadOnlyListOfStringProperty?.ToString() ?? "<null>"}, ReadOnlyListOfModelEquatableClassProperty = {this.ReadOnlyListOfModelEquatableClassProperty?.ToString() ?? "<null>"}.");

            return result;
        }
    }
}