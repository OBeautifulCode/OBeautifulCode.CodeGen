// --------------------------------------------------------------------------------------------------------------------
// <copyright file="ReflectionHelper.Method.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Reflection.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Reflection.Recipes
{
    using global::System;
    using global::System.Collections.Generic;
    using global::System.Linq;
    using global::System.Reflection;

    using static global::System.FormattableString;

#if !OBeautifulCodeReflectionSolution
    internal
#else
    public
#endif
    static partial class ReflectionHelper
    {
        /// <summary>
        /// Gets the methods of the specified type,
        /// with various options to control the scope of methods included and optionally order the methods.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="memberRelationships">OPTIONAL value that scopes the search for members based on their relationship to <paramref name="type"/>.  DEFAULT is to include the members declared in or inherited by the specified type.</param>
        /// <param name="memberOwners">OPTIONAL value that scopes the search for members based on who owns the member.  DEFAULT is to include members owned by an object or owned by the type itself.</param>
        /// <param name="memberAccessModifiers">OPTIONAL value that scopes the search for members based on access modifiers.  DEFAULT is to include members having any supported access modifier.</param>
        /// <param name="memberAttributes">OPTIONAL value that scopes the search for members based on the presence or absence of certain attributes on those members.  DEFAULT is to include members having or not having all special attributes.</param>
        /// <param name="orderMembersBy">OPTIONAL value that specifies how to the members.  DEFAULT is return the members in no particular order.</param>
        /// <returns>
        /// The methods in the specified order.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static IReadOnlyList<MethodInfo> GetMethodsFiltered(
            this Type type,
            MemberRelationships memberRelationships = MemberRelationships.DeclaredOrInherited,
            MemberOwners memberOwners = MemberOwners.All,
            MemberAccessModifiers memberAccessModifiers = MemberAccessModifiers.All,
            MemberAttributes memberAttributes = MemberAttributes.All,
            OrderMembersBy orderMembersBy = OrderMembersBy.None)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = type
                .GetMembersFiltered(memberRelationships, memberOwners, MemberMutability.All, memberAccessModifiers, MemberKinds.Method, memberAttributes, orderMembersBy)
                .Cast<MethodInfo>()
                .ToList();

            return result;
        }

        /// <summary>
        /// Gets the specified interface type's methods along with the methods of all implemented interfaces.
        /// </summary>
        /// <param name="interfaceType">The type of the interface.</param>
        /// <returns>
        /// The methods declared on the specified interface along with the methods of all implemented interfaces.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="interfaceType"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="interfaceType"/> is not an interface type.</exception>
        public static IReadOnlyCollection<MethodInfo> GetInterfaceDeclaredAndImplementedMethods(
            this Type interfaceType)
        {
            if (interfaceType == null)
            {
                throw new ArgumentNullException(nameof(interfaceType));
            }

            if (!interfaceType.IsInterface)
            {
                throw new ArgumentException(Invariant($"{nameof(interfaceType)} is not an interface type."));
            }

            var result = interfaceType
                .GetMembersFiltered(MemberRelationships.DeclaredInTypeOrImplementedInterfaces, memberKinds: MemberKinds.Method)
                .Cast<MethodInfo>()
                .ToList();

            return result;
        }
    }
}
