// --------------------------------------------------------------------------------------------------------------------
// <copyright file="ReflectionHelper.Property.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Reflection.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Reflection.Recipes
{
    using global::System;
    using global::System.Collections.Generic;
    using global::System.Diagnostics.CodeAnalysis;
    using global::System.Linq;
    using global::System.Reflection;

    using OBeautifulCode.CodeAnalysis.Recipes;
    using OBeautifulCode.Type.Recipes;

    using static global::System.FormattableString;

#if !OBeautifulCodeReflectionSolution
    internal
#else
    public
#endif
    static partial class ReflectionHelper
    {
        /// <summary>
        /// Determines if a type has a property of the specified property name.
        /// </summary>
        /// <param name="type">The type to check.</param>
        /// <param name="propertyName">The name of the property to check for.</param>
        /// <param name="bindingFlags">OPTIONAL binding flags to use when searching.  DEFAULT is to filter to <see cref="BindingFlagsFor.AllDeclaredAndInheritedMembers"/>.</param>
        /// <returns>
        /// true if the type has a property of the specified property name, false if not.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Justification = ObcSuppressBecause.CA1726_UsePreferredTerms_NameOfTypeOfIdentifierUsesTheTermFlags)]
        public static bool HasProperty(
            this Type type,
            string propertyName,
            BindingFlags bindingFlags = BindingFlagsFor.AllDeclaredAndInheritedMembers)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (propertyName == null)
            {
                throw new ArgumentNullException(nameof(propertyName));
            }

            if (string.IsNullOrWhiteSpace(propertyName))
            {
                throw new ArgumentException(Invariant($"{nameof(propertyName)} is white space."));
            }

            bool result;

            try
            {
                result = type.GetProperty(propertyName, bindingFlags) != null;
            }
            catch (AmbiguousMatchException)
            {
                result = true;
            }

            return result;
        }

        /// <summary>
        /// Gets the name of all of the properties.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="bindingFlags">OPTIONAL binding flags to use when searching.  DEFAULT is to filter to <see cref="BindingFlagsFor.AllDeclaredAndInheritedMembers"/>.</param>
        /// <returns>
        /// The property names.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Justification = ObcSuppressBecause.CA1726_UsePreferredTerms_NameOfTypeOfIdentifierUsesTheTermFlags)]
        public static IReadOnlyCollection<string> GetPropertyNames(
            this Type type,
            BindingFlags bindingFlags = BindingFlagsFor.AllDeclaredAndInheritedMembers)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var allProperties = type.GetProperties(bindingFlags);

            var result = allProperties.Select(_ => _.Name).ToList();

            return result;
        }

        /// <summary>
        /// Gets the <see cref="PropertyInfo"/> for the specified property.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="propertyName">The name of the property.</param>
        /// <param name="bindingFlags">OPTIONAL binding flags to use when searching.  DEFAULT is to filter to <see cref="BindingFlagsFor.AllDeclaredAndInheritedMembers"/>.</param>
        /// <returns>
        /// The <see cref="PropertyInfo"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
        /// <exception cref="ArgumentException">There is no property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">There is more than one property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Justification = ObcSuppressBecause.CA1726_UsePreferredTerms_NameOfTypeOfIdentifierUsesTheTermFlags)]
        public static PropertyInfo GetPropertyInfo(
            this Type type,
            string propertyName,
            BindingFlags bindingFlags = BindingFlagsFor.AllDeclaredAndInheritedMembers)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (propertyName == null)
            {
                throw new ArgumentNullException(nameof(propertyName));
            }

            if (string.IsNullOrWhiteSpace(propertyName))
            {
                throw new ArgumentException(Invariant($"{nameof(propertyName)} is white space."));
            }

            PropertyInfo result;

            try
            {
                result = type.GetProperty(propertyName, bindingFlags);

                if (result == null)
                {
                    throw new ArgumentException(Invariant($"There is no property named '{propertyName}' on type '{type.ToStringReadable()}', using the specified binding constraints."));
                }
            }
            catch (AmbiguousMatchException)
            {
                throw new ArgumentException(Invariant($"There is more than one property named '{propertyName}' on type '{type.ToStringReadable()}', using the specified binding constraints."));
            }

            return result;
        }

        /// <summary>
        /// Gets the value of a property.
        /// </summary>
        /// <typeparam name="T">The type of the property.</typeparam>
        /// <param name="item">The object.</param>
        /// <param name="propertyName">The name of the property.</param>
        /// <param name="bindingFlags">OPTIONAL binding flags to use when searching.  DEFAULT is to filter to <see cref="BindingFlagsFor.AllDeclaredAndInheritedMembers"/>.</param>
        /// <returns>
        /// The value of the property.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="item"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
        /// <exception cref="ArgumentException">There is no property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">There is more than one property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">The property does not have a get method.</exception>
        /// <exception cref="InvalidCastException">The property is not of the specified type.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Justification = ObcSuppressBecause.CA1726_UsePreferredTerms_NameOfTypeOfIdentifierUsesTheTermFlags)]
        public static T GetPropertyValue<T>(
            this object item,
            string propertyName,
            BindingFlags bindingFlags = BindingFlagsFor.AllDeclaredAndInheritedMembers)
        {
            if (item == null)
            {
                throw new ArgumentNullException(nameof(item));
            }

            var propertyInfo = item.GetType().GetPropertyInfo(propertyName, bindingFlags);

            var propertyValue = propertyInfo.GetValue(item);

            var result = propertyValue.CastOrThrowIfTypeMismatch<T>(propertyInfo);

            return result;
        }

        /// <summary>
        /// Gets the value of a property.
        /// </summary>
        /// <param name="item">The object.</param>
        /// <param name="propertyName">The name of the property.</param>
        /// <param name="bindingFlags">OPTIONAL binding flags to use when searching.  DEFAULT is to filter to <see cref="BindingFlagsFor.AllDeclaredAndInheritedMembers"/>.</param>
        /// <returns>
        /// The value of the property.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="item"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
        /// <exception cref="ArgumentException">There is no property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">There is more than one property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">The property does not have a get method.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Justification = ObcSuppressBecause.CA1726_UsePreferredTerms_NameOfTypeOfIdentifierUsesTheTermFlags)]
        public static object GetPropertyValue(
            this object item,
            string propertyName,
            BindingFlags bindingFlags = BindingFlagsFor.AllDeclaredAndInheritedMembers)
        {
            if (item == null)
            {
                throw new ArgumentNullException(nameof(item));
            }

            var propertyInfo = item.GetType().GetPropertyInfo(propertyName, bindingFlags);

            var result = propertyInfo.GetValue(item);

            return result;
        }

        /// <summary>
        /// Gets the value of a static property.
        /// </summary>
        /// <typeparam name="T">The type of the property.</typeparam>
        /// <param name="type">The type that contains the property.</param>
        /// <param name="propertyName">The name of the property.</param>
        /// <param name="bindingFlags">OPTIONAL binding flags to use when searching.  DEFAULT is to filter to <see cref="BindingFlagsFor.AllDeclaredAndInheritedStaticMembers"/>.</param>
        /// <returns>
        /// The value of the property.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
        /// <exception cref="ArgumentException">There is no property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">There is more than one property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">The property does not have a get method.</exception>
        /// <exception cref="ArgumentException">The property is not static.</exception>
        /// <exception cref="InvalidCastException">The property is not of the specified type.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Justification = ObcSuppressBecause.CA1726_UsePreferredTerms_NameOfTypeOfIdentifierUsesTheTermFlags)]
        public static T GetStaticPropertyValue<T>(
            this Type type,
            string propertyName,
            BindingFlags bindingFlags = BindingFlagsFor.AllDeclaredAndInheritedStaticMembers)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var propertyInfo = type.GetPropertyInfo(propertyName, bindingFlags);

            object propertyValue;

            try
            {
                propertyValue = propertyInfo.GetValue(null);
            }
            catch (TargetException)
            {
                throw new ArgumentException("The property is not static.");
            }

            var result = propertyValue.CastOrThrowIfTypeMismatch<T>(propertyInfo);

            return result;
        }

        /// <summary>
        /// Gets the value of a property on a static type.
        /// </summary>
        /// <param name="type">The type that contains the property.</param>
        /// <param name="propertyName">The name of the property.</param>
        /// <param name="bindingFlags">OPTIONAL binding flags to use when searching.  DEFAULT is to filter to <see cref="BindingFlagsFor.AllDeclaredAndInheritedStaticMembers"/>.</param>
        /// <returns>
        /// The value of the property.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
        /// <exception cref="ArgumentException">There is no property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">There is more than one property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">The property does not have a get method.</exception>
        /// <exception cref="ArgumentException">The property is not static.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Justification = ObcSuppressBecause.CA1726_UsePreferredTerms_NameOfTypeOfIdentifierUsesTheTermFlags)]
        public static object GetStaticPropertyValue(
            this Type type,
            string propertyName,
            BindingFlags bindingFlags = BindingFlagsFor.AllDeclaredAndInheritedStaticMembers)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var propertyInfo = type.GetPropertyInfo(propertyName, bindingFlags);

            object result;

            try
            {
                result = propertyInfo.GetValue(null);
            }
            catch (TargetException)
            {
                throw new ArgumentException("The property is not static.");
            }

            return result;
        }

        /// <summary>
        /// Sets a property's value.
        /// </summary>
        /// <param name="item">The object.</param>
        /// <param name="propertyName">The name of the property.</param>
        /// <param name="value">The value to set the property to.</param>
        /// <param name="bindingFlags">OPTIONAL binding flags to use when searching.  DEFAULT is to filter to <see cref="BindingFlagsFor.AllDeclaredAndInheritedMembers"/>.</param>
        /// <exception cref="ArgumentNullException"><paramref name="item"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
        /// <exception cref="ArgumentException">There is no property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">There is more than one property named <paramref name="propertyName"/> on the object type using the specified binding constraints.</exception>
        /// <exception cref="InvalidCastException">Unable to assign null to the property's type.</exception>
        /// <exception cref="InvalidCastException">Unable to assign <paramref name="value"/> type to the property's type.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Justification = ObcSuppressBecause.CA1726_UsePreferredTerms_NameOfTypeOfIdentifierUsesTheTermFlags)]
        public static void SetPropertyValue(
            this object item,
            string propertyName,
            object value,
            BindingFlags bindingFlags = BindingFlagsFor.AllDeclaredAndInheritedMembers)
        {
            if (item == null)
            {
                throw new ArgumentNullException(nameof(item));
            }

            var propertyInfo = item.GetType().GetPropertyInfo(propertyName, bindingFlags);

            value.ThrowIfNotAssignableTo(propertyInfo);

            propertyInfo.SetValue(item, value);
        }

        /// <summary>
        /// Sets a static property's value.
        /// </summary>
        /// <param name="type">The type that contains the property.</param>
        /// <param name="propertyName">The name of the property.</param>
        /// <param name="value">The value to set the property to.</param>
        /// <param name="bindingFlags">OPTIONAL binding flags to use when searching.  DEFAULT is to filter to <see cref="BindingFlagsFor.AllDeclaredAndInheritedStaticMembers"/>.</param>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="propertyName"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="propertyName"/> is whitespace.</exception>
        /// <exception cref="ArgumentException">There is no property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
        /// <exception cref="ArgumentException">There is more than one property named <paramref name="propertyName"/> on type <paramref name="type"/> using the specified binding constraints.</exception>
        /// <exception cref="InvalidCastException">Unable to assign null to the property's type.</exception>
        /// <exception cref="InvalidCastException">Unable to assign <paramref name="value"/> type to the property's type.</exception>
        /// <exception cref="ArgumentException">The property is not static.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Justification = ObcSuppressBecause.CA1726_UsePreferredTerms_NameOfTypeOfIdentifierUsesTheTermFlags)]
        public static void SetStaticPropertyValue(
            this Type type,
            string propertyName,
            object value,
            BindingFlags bindingFlags = BindingFlagsFor.AllDeclaredAndInheritedStaticMembers)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var propertyInfo = type.GetPropertyInfo(propertyName, bindingFlags);

            value.ThrowIfNotAssignableTo(propertyInfo);

            try
            {
                propertyInfo.SetValue(null, value);
            }
            catch (TargetException)
            {
                throw new ArgumentException("The property is not static.");
            }
        }

        private static T CastOrThrowIfTypeMismatch<T>(
            this object propertyValue,
            PropertyInfo propertyInfo)
        {
            var returnType = typeof(T);

            T result;

            if (propertyValue == null)
            {
                // can't solely rely on the (T) cast - if pi.GetValue returns null, then null can be cast to any reference type.
                var propertyType = propertyInfo.PropertyType;

                if (!returnType.IsAssignableFrom(propertyType))
                {
                    throw new InvalidCastException(Invariant($"Unable to cast object of type '{propertyType.ToStringReadable()}' to type '{returnType.ToStringReadable()}'."));
                }

                result = default;
            }
            else
            {
                try
                {
                    result = (T)propertyValue;
                }
                catch (InvalidCastException)
                {
                    throw new InvalidCastException(Invariant($"Unable to cast object of type '{propertyValue.GetType().ToStringReadable()}' to type '{returnType.ToStringReadable()}'."));
                }
            }

            return result;
        }

        private static void ThrowIfNotAssignableTo(
            this object value,
            PropertyInfo propertyInfo)
        {
            var propertyType = propertyInfo.PropertyType;

            if (value == null)
            {
                if (!propertyType.IsClosedTypeAssignableToNull())
                {
                    throw new InvalidCastException(Invariant($"Unable to assign null value to property of type '{propertyType.ToStringReadable()}'."));
                }
            }
            else
            {
                var valueType = value.GetType();

                if (!propertyType.IsAssignableFrom(valueType))
                {
                    throw new InvalidCastException(Invariant($"Unable to assign value of type '{valueType.ToStringReadable()}' to property of type '{propertyType.ToStringReadable()}'."));
                }
            }
        }
    }
}
